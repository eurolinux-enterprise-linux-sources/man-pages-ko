.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) Markus Kuhn, 1996
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" 1995-11-26  Markus Kuhn <mskuhn@cip.informatik.uni-erlangen.de>
.\"      First version written
.\"
.TH MLOCK 2 "1995년 11월 26일" "리눅스 1.3.43" "리눅스 프로그래머 매뉴얼"
.SH 이름
mlock \- 메모리의 일정 영역에 대한 페이징을 금지시킨다.
.SH 사용법
.nf
.B #include <sys/mman.h>
.sp
\fBint mlock(const void *\fIaddr\fB, size_t \fIlen\fB);
.fi
.SH 설명
.BR mlock 은 
.IR addr 부터 
.IR len
바이트 만큼의 메모리에 대한 페이징을 금지시킨다.
지정된 메모리 범위의 일부를 포함하는 모든 페이지들은 
.B mlock
시스템 콜이 성공했을 때 RAM에 상주하는 것이 보장된다.
그리고 이 페이지들은 
.BR munlock 이나 
.BR munlockall 에 
의해 잠금이 풀릴 때까지 또는 프로세스가 종료할 때까지 또는 
.BR exec 에 
의해 다른 프로그램이 시작할 때까지 RAM에 상주하는 것이 보장된다.
.BR fork 에
의한 자식 프로세스는 페이지 잠금을 상속받지 않는다.

메모리 잠금은 주로 두 가지 경우에 응용된다: 
실시간 알고리즘과 high-security 데이타 처리.
실시간 응용프로그램의 경우는 결정론적인 타이밍과 스케줄링 같은 
것이 요구되는데, 이 때 페이징은 예상치 못한 프로그램 실행 지연을 
야기하는 주요 원인이다. 또한 실시간  응용프로그램은 보통 
.BR sched_setscheduler 로
실시간 스케쥴러를 사용한다. 암호 보안 소프트웨어는 데이터로 암호나 
보안키 같은 중요 바이트를 처리한다. 페이징 결과, 이 데이터가 지속적인 
스왑 저장 장치에 저장되며 보안 소프트웨어가 RAM에서 이 데이터를 지우고 
끝난 후에도 오랫동안 외부에 노출될 수 있다.

메모리 잠근은 스택이 아니다.
즉,  
.BR mlock 이나 
.BR mlockall 이
여러번 호출되어 여러번 잠겼던 페이지는 상응하는 범위에 대한
.BR munlock 이나 
.BR munlockall 를 
단 한번 호출하여 잠금을 풀 수 있다.
여러 위치나 여러 프로세스에 의해 잠겨진 페이지는 적어도 하나의 
위치나 프로세스에 의해 잠겨져 있는 한 RAM에서 계속적으로 잠금이 유지된다.

.BR mlock 과
.BR munlock 를 
이용할 수 있는 POSIX 시스템에서 
.BR _POSIX_MEMLOCK_RANGE 는 
<unistd.h>에 정의되어 있으며 <limits.h>에서
.BR PAGESIZE 는 
페이지당 바이트 수를 가리킨다.

.SH 반환값
성공시, 
.BR mlock 은 
0을 리턴한다. 에러시, \-1이 리턴되며, 
.IR errno 는 
적절한 값으로 설정된다. 그리고 해당 프로세스의 주소 공간의
잠금에 어떠한 변화도 일어나지 않는다.
.SH 에러
.TP
.B ENOMEM
지정된 주소의 일정 부분이 해당 프로세스 주소 공간의 페이지와 
일치하지 않거나, 프로세스가 허용되는 잠금 페이지의 최대 수를 초과했다.
.TP
.B EPERM
호출한 프로세스가 올바른 권한을 갖고 있지 않다.
단지 루트 프로세스에만 페이지의 잠금을 허용된다.
.TP
.B EINVAL
.IR len 이 
양수가 아니다.
.SH 호환
POSIX.1b, SVr4. SVr4는 EAGAIN 에러 조건을 추가적으로 기술한다.
.SH 관련 항목
.BR munlock (2),
.BR mlockall (2),
.BR munlockall (2)
.SH 역자
정강훈 <skyeyes@soback.kornet.net>, 2000년 5월 20일
