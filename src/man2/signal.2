.\" Copyright (c) 1994 Mike Battersby <mike@starbug.apana.org.au>
.\" based on work by faith@cs.unc.edu
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified, aeb, 960424, 960621
.\" FIXME - error conditions need to be documented
.TH SIGNAL 2 "1996년 7월 21일" "리눅스 2.0" "리눅스 프로그래머 매뉴얼"
.SH 이름
signal \- ANSI C 시그널 처리
.SH 사용법
.B #include <signal.h>
.sp
.BI "void (*signal(int " signum ", void (*" handler ")(int)))(int);"
.SH 설명
.B signal
시스템 콜은 
.I signum
번호의 시그널에 대해 새로운 시그널 핸들러를 설치한다.
시그널 핸들러는 
.IR handler 로 
설정되고, 사용자 정의 함수이거나 다음 것중의 하나가 될 수 있다:
.RS
.TP
.B SIG_IGN
시그널을 무시한다.
.TP
.B SIG_DFL
시그널의 초기 기본 동작을 하도록 한다.
.RE
.PP
시그널 핸드러 루틴에 넘겨지는 정수 인자는 시그널 번호이다. 이는 여러 시그널에
대해 하나의 시그널 핸들러를 사용할 수 있게 한다.

.SH 반환값
.BR signal 은
이전의 시그널 핸들러의 포인터나, 에러시
.BR SIG_ERR 를
리턴한다.

.SH 주의
.BR SIGKILL "나 " SIGSTOP "에 "
시그널 핸들러를 지정할 수 없다.
.PP
BSD 시스템과 달리, 리눅스의 시그널은 시그널이 발생했을 때 초기 기본 동작으로
되돌린다. 
그러나, 
.B "<signal.h>"
대신에 
.BR "<bsd/signal.h>" 를
포함시키면
.BR signal
은
.BR __bsd_signal 로
재정의되어 시그널은 BSD에서와 같이 동작한다. 
.BR signal의 
두 가지 버전은 모두  
.BR sigaction (2)위에
만들어진 라이브러리 루틴이다.
.PP
이 맨페이지의 프로토타입이 이해되지 않는다면 다음과 같이 분리하는 것이
도움이 될지도 모른다: 
.PP
typedef void (*sighandler_t)(int);
.br
.BI "sighandler_t signal(int " signum ", sighandler_t " handler );
.PP
POSIX에 따르면 \fIkill()\fP나 \fIraise()\fP 함수로 발생시킬 수 없는 
SIGFPE, SIGILL 또는 SIGSEGV 시그널을 무시한 후 프로세스의 동작을 알
수 없다. 
0으로 나눠진 정수는 알 수 없는 결과를 낸다.
어떤 아키텍쳐에서는 SIGFPE 시그널이 발생한다. (-1로 음의 정수를 나누는
것도 SIGFPE를 발생시킨다.) 이 시그널을 무시하면 무한 루프에 빠질 수도 
있다.
.PP
POSIX (B.3.3.1.3)에 따르면 SIGCHLD에 대한 동작은 SIG_IGN으로 설정해서는 안
된다. 여기서 BSD와 SYSV가 다르다. SIGCHLD의 동작을 SIG_IGN으로 설정하는 
BSD 소프트웨어는 리눅스에서는 실패한다. 

.SH 호환
ANSI C

.SH 관련 항목
.BR kill (1),
.BR kill (2),
.BR killpg (2),
.BR pause (2),
.BR raise (3),
.BR sigaction (2),
.BR signal (7),
.BR sigsetops (3),
.BR sigvec (2),
.BR alarm (2)
.SH 역자
임종균 <hermes44@secsm.org>, 2000년 4월 20일
