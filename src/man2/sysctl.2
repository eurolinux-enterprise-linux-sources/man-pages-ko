.\" Copyright (C) 1996 Andries Brouwer (aeb@cwi.nl)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Written 11 April 1996 by Andries Brouwer <aeb@cwi.nl>
.\" 960412: Added comments from Stephen Tweedie
.\" Modified Tue Oct 22 22:28:41 1996 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified Mon Jan  5 20:31:04 1998 by aeb.
.\"
.TH SYSCTL 2 "1996년 5월 11일" "Linux 1.3.85" "리눅스 프로그래머 매뉴얼"
.SH 이름
sysctl \- 시스템 파라미터들을 읽고 쓴다.
.SH 사용법
.B #include <unistd.h>
.sp
.B #include <linux/unistd.h>
.sp
.B #include <linux/sysctl.h>
.sp
.B _syscall1(int, _sysctl, struct __sysctl_args *, args);
.sp
.BI "int _sysctl(struct __sysctl_args *" args );
.SH 설명
.B _sysctl
시스템 콜은 커널 파리미터들을 읽고 쓴다.
예를 들어, 호스트 이름이나 열린 파일들의 최대 수 등이다.
인자는 다음과 같은 형태이다:
.PP
.nf
struct __sysctl_args {
        int *name;        /* 변수를 가리키는 integer vector */
        int nlen;         /* 이 벡터의 길이*/
        void *oldval;     /* 0 또는 예전 값을 저장하기 위한 주소*/
        size_t *oldlenp;  /* 예전 값을 위해 이용할수 있는 공간,
					  예전 값의 실제 크기에 의해 위에 쓰여진다.*/
        void *newval;     /* 0 또는 새로운 값의 주소*/
        size_t newlen;    /* 새로운 값의 크기*/
};
.fi
.PP
이 함수는 트리 구조에서 탐색을 하며
.BR /proc/sys 아래의 
디렉토리 트리와 비슷하다. 그리고 만일 요구된 아이템이 발견된다면 
몇몇 적당한 루틴들이 이 값을 읽거나 번경하기 위해서 호출된다.
.SH 예제
.nf
#include <linux/unistd.h>
#include <linux/types.h>
#include <linux/sysctl.h>

_syscall1(int, _sysctl, struct __sysctl_args *, args);
int sysctl(int *name, int nlen, void *oldval, size_t *oldlenp,
           void *newval, size_t newlen)
{
        struct __sysctl_args args={name,nlen,oldval,oldlenp,newval,newlen};
        return _sysctl(&args);
}

#define SIZE(x) sizeof(x)/sizeof(x[0])
#define OSNAMESZ 100

char osname[OSNAMESZ];
int osnamelth;
int name[] = { CTL_KERN, KERN_OSTYPE };

main(){
        osnamelth = SIZE(osname);
        if (sysctl(name, SIZE(name), osname, &osnamelth, 0, 0))
                perror("sysctl");
        else
                printf("This machine is running %*s\en", osnamelth, osname);
        return 0;
}
.fi

.SH 반환값
성공시, 
.B _sysctl
는 0이 리턴되다. 그렇지 않으면, \-1 값이 리턴되며 
.I errno
는 에러를 가리키며 설정된다.
.SH 에러
.TP
.B ENOTDIR
.I name
이 발견되지 않았다.
.TP
.B EPERM
만난 `directories'중 하나에 대한 탐색 허가권이 없거나,
.I oldval
가 0이 아닌곳의 읽기 허가권이 없거나, 
.I newval
이 0이 아닌곳의 쓰기 허가권이 없다.
.TP
.B EFAULT
호출은 non-NULL인 
.I oldval 
를 설정하여 전 값을 요구했지만, 
.IR oldlenp 에
있는 곳은 0 을 허가한다.
.SH 호환
이 함수는 리눅스에 의존하며 호환성을 염두에 둔 프로그램에서 사용해서는
안된다.

.B sysctl
시스템 콜은 Linux 버전 1.3.57이후부터 존재한다.
이것은 4.4BSD에 기반을 두고 있다. 단지 리눅스만이
.I /proc/sys
를 반영하고 있으며 객체 이름 구조들은 Linux와 BSD 4.4에서 서로  다르다.
그러나, 
.BR sysctl (2) 함수의
선언은 양쪽 모두 같다.
.SH 버그
객체 이름들은 커널 버전에 따라 다른다.
이 시스템 콜은 응용프로그램에서는 쓸모가 없다.
대신에 
.I /proc/sys
를 사용해라.
.br
이용할수 있는 모든 객체들이 문서화 되어 있지는 않다.
.br
아직은 
.IR /proc/sys/kernel/ostype 에
쓰기를 하여 OS를 변경하는것은 가능하지 않다.
.SH 관련 항목
.BR proc (5)
.SH 역자
정강훈 <skyeyes@soback.kornet.net>, 2000년 7월 8일
