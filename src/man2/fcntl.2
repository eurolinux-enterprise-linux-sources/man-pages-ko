.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" This manpage is Copyright (C) 1992 Drew Eckhardt;
.\"                               1993 Michael Haardt, Ian Jackson;
.\"                               1998 Jamie Lokier.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified Sat Jul 24 13:39:26 1993 by Rik Faith <faith@cs.unc.edu>
.\" Modified Tue Sep 26 21:47:21 1995 by Andries Brouwer <aeb@cwi.nl>
.\" and again on 960413 and 980804 and 981223.
.\" Modified Fri Dec 11 17:57:27 1998 by Jamie Lokier <jamie@imbolc.ucc.ie>
.\" Applied correction by Christian Ehrhardt - aeb, 990712
.\"
.\"
.\" 한국어 번역 : ASPLINUX <man@asp-linux.co.kr> 2000년 7월 29일
.\"
.\" r1.2 2005-02-17 16:25:03 +108-86 윤현호
.\" r1.1 2004-05-07 20:19:31  220.73.230.224
.\"
.TH FCNTL 2 "12 July 1999" Linux "Linux Programmer's Manual"
.SH 이름
fcntl \- 파일 기술자(file descriptor) 조작
.SH 사용법
.nf
.B #include <unistd.h>
.B #include <fcntl.h>
.sp
.BI "int fcntl(int " fd ", int " cmd );
.BI "int fcntl(int " fd ", int " cmd ", long " arg );
.BI "int fcntl(int " fd ", int " cmd ", struct flock * " lock );
.fi
.SH 설명
.B fcntl
.IR fd 에서
다양한 연산들 중 하나를 수행한다. 문제 중 연산은
.IR cmd 에
의해 결정된다:
.TP 0.9i
.B F_DUPFD
.IR arg 보다
크거나 동일한 가장 낮은 숫자가 지명된 사용가능한 파일 기술자를 찾고, 그것이
.IR fd 의
복사본이 되도록 하라. 이는 엄밀하게 지정된 기술자를 사용하는
.BR dup2 (2)와는
다르다.
.sp
오래된 그리고 새로운 기술자들은 교대적으로 사용될 수 있다. 이들은 잠금(lock), 파일 위치
포인터 그리고 플래그를 공유한다. 예를 들면, 기술자들중 하나에서 파일 위치가
.BR lseek 를
사용해서 수정되면, 위치는 또한 다른 것에 대해 변경될 수 있다.
.sp
두 기술자들은 close-on-exec  플래그를 공유하지 않는다. 그러나 복제본의 close-on-exec
플래그는 실행중에는 종료되지 않는 off 상태가 된다.
.sp
성공하면, 새로운 기술자는 리턴된다.
.TP
.B F_GETFD
close-on-exec를 읽는다. 만일
.B FD_CLOEXEC
비트가 0이면, 파일은
.BR exec 를
통해 열린 상태로 남겨지고, 그렇지 않으면, 닫힌다.
.TP
.B F_SETFD
close-on-exec 플래그를
.IR arg 의
.B FD_CLOEXEC
비트에 의해 지정된 값으로 설정한다.
.TP
.B F_GETFL
기술자의 플래그를 읽는다. (모든 플래그(
.BR open (2)에
의해 설정된)들은 리턴된다.)
.TP
.B F_SETFL
.IR arg
에 의해 지정된 값을 기술자의 플래그로 설정한다. 오직
.BR O_APPEND ", " O_NONBLOCK " 그리고 " O_ASYNC
이 설정될 수 있다. 다른 플래그들은 영향을 받지 않는다.
.sp
플래그들은
.BR dup "(2), " fork (2)
로 만들어진 동일한 파일 기술자의 복사본들 사이에 공유된다.
.sp
플래그 및 그들의 의미는
.BR open (2)에
설명되어 있다.
.P
.BR F_GETLK ", " F_SETLK " 그리고 " F_SETLKW
들은 임의의 파일 잠금을 관리하는데 사용된다.
세번째 인수
.IR lock 은
구조체 flock(이 호출에 의해 겹쳐써질 수 있는)에 대한 포인터이다.
.TP
.B F_GETLK
잠금을 얻을 수 없도록 제어하는 flock 구조로 리턴하거나, 다른 장애가 없다면,
 잠금의
.B l_type
필드를
.BR F_UNLCK 으로
설정한다.
.TP
.B F_SETLK
.BR l_type 이
.B F_RDLCK
혹은
.BR F_WRLCK 일
때, 잠금이 설정된거나,
.BR l_type 이
.BR F_UNLCK 일
때, 잠금은 소거된다.
다른 누군가에 의해 잠금(lock)이 이루어지면, 이 호출은 -1을 리턴하고,
.IR errno 를
.B EACCES
혹은
.BR EAGAIN 로
설정한다.
.TP
.B F_SETLKW
.BR F_SETLK 과
같지만, 에러를 리턴하는 대신에, 잠금이 풀려지기를 기다린다. 만일
.BR fcntl 이
기다리고 있을 때, 시그널이 잡히면,
이는 인터럽트되고, 시그널 처리기가 리턴된 후에, 즉시 리턴값 -1과
.IR errno 가
.BR EINTR 로
설정되어 리턴된다.
.P
.BR F_GETOWN ", " F_SETOWN ", " F_GETSIG " 그리고 " F_SETSIG
입출력(I/O) 유용성 시그널을 관리하는데 사용된다.
.TP
.B F_GETOWN
파일 기술자
.IR fd 상에서
이벤트들에 대한 SIGIO 그리고 SIGURG 시그널들을
수신하는 프로세스 ID 또는 프로세스 그룹을 얻는다.

.TP
.B F_SETOWN
파일 기술자
.IR fd 상에서
이벤트들에 대한 SIGIO 그리고 SIGURG 시그널들을
수신하는 프로세스 ID 또는 프로세스 그룹을 설정한다.
프로세스 그룹들은 음수값을 사용하여 지정된다.
.RB ( F_SETSIG
은 SIGIO 대신에 다른 시그널을 명시하는데 사용될 수 있다.
.\" From glibc.info:
만일 파일 기술자에서
이 플래그에
.IR open (2)
호출을 제공하거나,
.BR fcntl 의
.B F_SETFL
명령을 사용하여
.B O_ASYNC
상태 플래그를 설정하려면,
입력 또는 출력이 그 파일 기술자에서 가능하게 될때마다,
SIGIO 시그널이 전송된다.
.sp
시그널을 수신할 프로세스 혹은 프로세스 그룹은
.B fcntl
함수에 대한
.B F_SETOWN
명령을 사용함으로서 선택될 수 있다.
만일 파일 기술자가 소켓이면, 이는 또한 대여폭을 벗어난 데이터가 그 소켓에 도착할때
전달되는 SIGURG 시그널의 수신자를 선택한다.  (SIGURG는
.BR select (2)는
소켓을 "예외적인 조건"으로 보고하는 어떤 상황에서든 전송된다.
만일 파일 기술자가 터미널 장치와 일치한다면, SIGIO 시그널들은 터미널의
포그라운드 프로세스 그룹에 전송된다.
.TP
.B F_GETSIG
입력 또는 출력이 가능해질 때, 시그널이 전송되도록 한다. 제로 값은 SIGIO가 전송되었다는
것을 의미한다. 다른 값(SIGIO을 포함)은 대신 보내진 시그널이다. 이런 경우, SA_SIGINFO가
설치되어 있으면, 시그널 처리기에 대한 추가적인 정보가 사용가능하다.
.TP
.B F_SETSIG
입력 또는 출력이 가능해질때, 시그널이 전송되도록 설정한다. 제로 값은 디폴트 SGSIO 시그널을
전송하는 것을 의미한다. 다른 값(SIGIO을 포함)은 대신 보내진 시그널이다. 이런 경우, SA_SIGINFO가
설치되어 있으면, 시그널 처리기에 대한 추가적인 정보가 사용가능하다.
.sp
제로가 아닌 값으로 F_SETSIG을 사용하고, 시그널 처리기에 대한 SA_SIGINFO를
설정(
.BR sigaction (2)
참조할 것)함으로서,
입출력(I/O 이벤트에 대한) 기타 정보가
.I siginfo_t
내의 처리기로 전달된다.
.I si_code
필드는 소스가 SI_SIGIO라는 것을 가리키고,
.I si_fd
필드는 파일 기술자와 이벤트를 관련시킨다. 그렇지 않으면, 어떤 파일 기술자들이
계류중인가에 대한 지시가 없고, 여러분은 입출력(I/O)에 사용가능한 파일 기술자들이
어떤 것인지를 결정하기 위해 유용한 메커니즘(
.RB ( select (2),
.BR poll (2),
.BR read (2)
.B O_NONBLOCK
)을 사용해야 한다.
.sp
POSIX.1b 실시간 시그널(값 >= SIGRTMIN)을 선택함으로서, 다중 입출력 이벤트들은 동일한
시그널 넘버들을 사용하여 대기행렬(큐)에 넣을 수 있다. (큐는 보통 사용가능한 메모리에 의존적이다.)
위와 같이 시그널 처리기에 대해 SA_SIGINFO가 설정되면, 기타 정보가 사용가능하다.
.PP
이러한 메커니즘을 사용하면, 프로그램은 대부분의 시간을
.BR select (2)
혹은
.BR poll (2)을
사용함 없이, 비동기적 입출력(I/O)을 구현할 수 있다.
.PP
.BR O_ASYNC ,
.BR F_GETOWN ,
.B F_SETOWN
의 사용은 BSD 및 리눅스에 특정적이다.
.B F_GETSIG
와
.B F_SETSIG는
리눅스에만 특정적이다.   POSIX는 비슷한 것들을 이루는데 비동기적 입출력과
.I aio_sigevent
구조를 이용한다. 이러한 것들은 또한 리눅스에서 GNU C 라이브러리(Glibc)의 부분으로서
사용할 수 있다.
.SH 반환값
성공적인 호출에 대하여, 리턴 값은 연산에 의존적이다.
.TP 0.9i
.B F_DUPFD
새로운 기술자
.TP
.B F_GETFD
플래그의 값
.TP
.B F_GETFL
플래그의 값
.TP
.B F_GETOWN
기술자 소유자의 값
.TP
.B F_GETSIG
읽기 또는 쓰기가 가능해졌을때 전송된 시그널의 값이나, 전통적인  SIGIO 행위에 대한 zero.
.TP
다른 모든 명령어
Zero.
.PP
에러면, \-1이 리턴되고,
.IR errno 는
적절하게 설정된다.
.SH 에러
.TP 0.9i
.B EACCES
연산은 다른 프로세스에 의한 잠김에 의해 금지된다.
.TP
.B EAGAIN
파일이 다른 프로세스에 의해 메모리 매핑이되었기 때문에, 연산은 방해받는다.
.TP
.B EBADF
.IR fd 는
열린 파일 기술자가 아니다.
.TP
.B EDEADLK
지정된
.B F_SETLKW
명령은 Deadlock을 초래할 것이라는 것이 감지되었다.
.TP
.B EFAULT
.IR lock 은
여러분이 접근할 수 있는 주소 공간의 바깥에 있다.
.TP
.B EINTR
.BR F_SETLKW 에
대하여, 명령은 시그널에 의해 인터럽트되었다.
.BR F_GETLK "과 " F_SETLK 에
대하여, 명령은 잠김이 체크되거나, 이루어지기 전에 시그널에 의해 인터럽트되었다.
원격 파일을 잠그는(NFS 잠금) 것은 보통 로컬에서 발생한다.
.TP
.B EINVAL
.BR F_DUPFD 에
대하여,
.IR arg 은
음수 값이거나, 허용된 최대값보다는 크다.
.BR F_SETSIG 에
대하여,
.IR arg 은
허용될 수 있는 시그널 넘버가 아니다.
.TP
.B EMFILE
.BR F_DUPFD 에
대하여, 프로세스는 이미 파일 기술자들의 최대 넘버가 열리도록 한다.
.TP
.B ENOLCK
너무나 많은 시그먼트 잠금이 열렸고, 잠금 테이블은 꽉찼거나, 원격 잠금 프로토콜이
실패하였다. (NFS를 통해 잠그기)
.TP
.B EPERM
추가 속성이 지정되도록 하는 파일에서
.B O_APPEND
플래그를 소거하고자 함
.SH 주의
.BR dup2 에
의해 리턴된 에러들은
.BR F_DUPFD 에
의해 리턴된 에러들과는 다르다.
.SH 호환
SVr4, SVID, POSIX, X/OPEN, BSD 4.3.  오직 F_DUPFD,
F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK, F_SETLK 그리고 F_SETLKW의 연산들만이
POSIX.1내에 명시되어 있다.  F_GETOWN 과 F_SETOWN 들은 SVr4에서 지원되지 않는 BSDism이다.
 F_GETSIG 과 F_SETSIG는 리눅스에 특정적이다. F_GETFL/F_SETFL용 플래그들은
.BR open (2)에
의해 지원되는 플래그들이고, 시스템에 따라 다르다.
O_APPEND, O_NONBLOCK, O_RDONLY, 그리고 O_RDWR은  POSIX.1내에 명시되어 있다.
SVr4은 여기에서 문서화하지 않은 몇개의 다른 옵션들과 플래그를 지원한다.

.PP
SVr4는 추가적인 EIO, ENOLINK 그리고 EOVERFLOW 에러 조건들에 대한 문서화를 한다.
.SH 관련 항목
.BR dup2 (2),
.BR open (2),
.BR socket (2),
.BR flock (2)
.SH 번역
ASPLINUX <man@asp-linux.co.kr> 2000년 7월 29일
.br
한글 Manpage 프로젝트 (http://man.kldp.org) 2005년 2월 17일
