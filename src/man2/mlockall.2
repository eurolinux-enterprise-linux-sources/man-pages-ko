.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) Markus Kuhn, 1996
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" 1995-11-26  Markus Kuhn <mskuhn@cip.informatik.uni-erlangen.de>
.\"      First version written
.\"
.TH MLOCKALL 2 "1995년 11월 26일" "리눅스 1.3.43" "리눅스 프로그래머 매뉴얼"
.SH 이름
mlockall \- 호출한 프로세스의 페이징을 금지시킨다.
.SH 사용법
.nf
.B #include <sys/mman.h>
.sp
\fBint mlockall(int \fIflags\fB);
.fi
.SH 설명
.BR mlockall 은
호출한 프로세스의 주소 공간에 대응되는 모든 페이지에 대한 페이징을 금지시킨다.
여기에는 코드, 데이터와 스택 페이지 또한 공유 라이브러리, 사용자 영역 커널 
데이터, 공유 메모리, 메모리에 대응된 파일이 포함된다. 모든 페이지는 
.BR mlockall 이
성공했을 때 RAM에 상주하는 것이 보장된다. 그리고 
.BR munlock 이나
.BR munlockall 에
의해 다시 잠금이 풀릴 때까지 또는 프로세스가 종료할 때까지 또는 
.BR exec 에
의해 다른 프로그램이 시작될 때까지 RAM에 상주하는 것이 보장된다.
.BR fork 에
의한 자식 프로세스는 페이지 잠금을 상속받지 않는다.

메모리 잠금은 주로 두 가지 경우에 응용된다: 
실시간 알고리즘과 high-security 데이타 처리.
실시간 응용프로그램의 경우는 결정론적인 타이밍과 스케줄링 같은 
것이 요구되는데, 이 때 페이징은 예상치 못한 프로그램 실행 지연을 
야기하는 주요 원인이다. 또한 실시간  응용프로그램은 보통 
.BR sched_setscheduler 로
실시간 스케쥴러를 사용한다. 암호 보안 소프트웨어는 데이터로 암호나 
보안키 같은 중요 바이트를 처리한다. 페이징 결과, 이 데이터가 지속적인 
스왑 저장 장치에 저장되며 보안 소프트웨어가 RAM에서 이 데이터를 지우고 
끝난 후에도 오랫동안 외부에 노출될 수 있다. 보안 응용 프로그램에서 작은
메모리 영역만을 잠가야하고, 이 때는 
.BR mlock 을
이용하기 적당하다.

.I flags
인자는 다음 상수를 논리 OR를 하여 지정될 수 있다.
.TP 1.2i
.B MCL_CURRENT
프로세스의 주소 공간에 현재 대응되는 모든 페이지를 잠근다.
.TP
.B MCL_FUTURE
앞으로 프로세스의 주소 공간에 대응될 모든 페이지를 잠근다. 예를 들어 새로운 
메모리 대응 파일이나 공유 메모리 영역 뿐만아니라 늘어난 힙과 스택의 페이지에 
사용되는 페이지에 해당된다.
.PP
만약
.BR MCL_FUTURE 이
지정되고 잠긴 페이지 수가 허용된 한계를 초과하면 시스템 콜은
.BR ENOMEM
에러로 실패할 것이다.
스택이 늘어나 새 페이지가 대응되면, 커널은 스택 확장을 거부하고 
.BR SIGSEGV
시그널을 보낸다.

실시간 프로세스는 시간 임계 영역을 수행하기 전에 충분한 스택 페이지를
잠가두어, 그 함수 호출에 의해 페이지 오류가 발생하지 않는다. 이는 충분히
큰 지역 변수를 가지고, 스택 페이지를 만들기 위해 이 큰 배열이 차지한 메모리에
쓰기를 하는 함수를 호출하여서 이룰 수 있다. 이런 방법으로 충분한 페이지를 
스택에 대응시켜 RAM에 잠가둘 수 있다. 이 쓰기는 임계 영역에서 copy-on-write
페이지 오류가 발생하지 않게 한다.
 
메모리 잠근은 스택이 아니다.
즉,  
.BR mlock 이나 
.BR mlockall 이
여러번 호출되어 여러번 잠겼던 페이지는 상응하는 범위에 대한
.BR munlock 이나 
.BR munlockall 를 
단 한번 호출하여 잠금을 풀 수 있다.
여러 위치나 여러 프로세스에 의해 잠겨진 페이지는 적어도 하나의 
위치나 프로세스에 의해 잠겨져 있는 한 RAM에서 계속적으로 잠금이 유지된다.

.BR mlockall 과
.BR munlockall 를 
이용할 수 있는 POSIX 시스템에서 
.BR _POSIX_MEMLOCK 은
<unistd.h>에 정의되어 있다.

.SH 반환값
성공시,
.BR mlockall 은
0을 리턴한다. 에러시, \-1 을 리턴하며,
.IR errno 는
적절한 값으로 설정된다.
.SH 에러
.TP
.B ENOMEM
프로세스가 허용되는 잠금 페이지의 최대 수를 초과했다.
.TP
.B EPERM
호출한 프로세스가 올바른 권한을 갖고 있지 않다.
단지 루트 프로세스에만 페이지의 잠금을 허용된다.
.TP
.B EINVAL
잘못된 flags가 지정되었다.
.SH 호환
POSIX.1b, SVr4. SVr4는 EAGAIN 에러 조건을 추가적으로 기술한다.
.SH 관련 항목
.BR munlockall (2),
.BR mlock (2),
.BR munlock (2)
.SH 역자
임종균 <hermes44@secsm.org>, 2000년 5월 26일
