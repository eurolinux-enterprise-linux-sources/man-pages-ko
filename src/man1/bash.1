.\"
.\" MAN PAGE COMMENTS to
.\"
.\"	Chet Ramey
.\"	Information Network Services
.\"	Case Western Reserve University
.\"	chet@ins.CWRU.Edu
.\"
.\"	Last Change: Fri May  5 10:44:39 EDT 1995
.\"
.\"	Translation into Korean by Man-Yong Lee
.\"	yong@korealinux.co.kr
.\"	yong@alzzalinux.com
.\"
.\"	Tue July  6 18:47:00 KST 1999
.\"
.\" bash_builtins, strip all but Built-Ins section
.if \n(zZ=1 .ig zZ
.TH BASH 1 "1995 May 5" GNU
.\"
.\" There's some problem with having a `@'
.\" in a tagged paragraph with the BSD man macros.
.\" It has to do with `@' appearing in the }1 macro.
.\" This is a problem on 4.3 BSD and Ultrix, but Sun
.\" appears to have fixed it.
.\" If you're seeing the characters
.\" `@u-3p' appearing before the lines reading
.\" `possible-hostname-completions
.\" and `complete-hostname' down in READLINE,
.\" then uncomment this redefinition.
.\"
.de }1
.ds ]X \&\\*(]B\\
.nr )E 0
.if !"\\$1"" .nr )I \\$1n
.}f
.ll \\n(LLu
.in \\n()Ru+\\n(INu+\\n()Iu
.ti \\n(INu
.ie !\\n()Iu+\\n()Ru-\w\\*(]Xu-3p \{\\*(]X
.br\}
.el \\*(]X\h|\\n()Iu+\\n()Ru\c
.}f
..
.\"
.\" File Name macro.  This used to be `.PN', for Path Name,
.\" but Sun doesn't seem to like that very much.
.\"
.de FN
\fI\|\\$1\|\fP
..
.SH 이름
bash \- GNU Bourne\-Again SHell
.SH 개요
.B bash
[옵션]
[파일]
.SH 저작권
.if n Bash is Copyright (C) 1989, 1991 by the Free Software Foundation, Inc.
.if t Bash is Copyright \(co 1989, 1991 by the Free Software Foundation, Inc.
.SH 설명
.B Bash
는 \fBsh\fR\-호환의 명령 언어 해석기로서 표준 입력 또는 파일로부터
읽어들인 명령을 실행한다.
.B Bash
는 또한  \fI콘쉘\fP 과 \fIC\fP 쉘(\fBksh\fP, \fBcsh\fP)로부터 유용한 기능을
도입하였다.
.PP
.B Bash
는 IEEE POSIX 쉘과 도구 명세(IEEE Working Group 1003\.2)에 호환되도록
쉘을 구현하겠다는 목표를 가지고 있다.
.SH 옵션
\fBset\fR 내부 명령 기술 부분에서 설명하고 있는 단일 문자 쉘 옵션 외에도
\fBbash\fR는 실행될 때 다음 플래그(flag)도 해석한다
(역자 주 : 앞으로 option은 옵션, flag는 플래그, parameter는 매개변수,
그리고 argument는 전달인수 또는 간단히 인수로 해석한다):
.PP
.PD 0
.TP 10
.BI \-c "\| 문자열\^"
.B \-c
플래그가 있으면,
.IR 문자열
로부터 명령을 읽어들인다.
.IR 문자열
뒤에 전달인수가 있으면, 그 전달인수는
.BR $0
부터 시작하여 위치 매개변수로 지정된다.
.TP
.B \-i
.B \-i
플래그가 있으면, 쉘은 
.IR 대화형
(interactive)모드로 동작한다.
.TP
.B \-s
.B \-s
플래그가 있을 때 또는 옵션 처리 후에 남은 인수가 없을 때에는
표준 입력으로부터 명령을 읽어들인다.
이 옵션을 사용하여 대화형 쉘을 실행시킬 때 위치 매개변수를
설정할 수 있다.
.TP
.B \-
.B \-
한 글자는 옵션이 끝났음을 알리는 표시이며 더 이상 옵션 처리를 하지
않도록 지시한다.
.B \-
다음의 인수는 모두 파일 이름과 인수로 받아들여진다.
글자 그대로 \fB\-\fP라는 인수를 표현하려면
.B \-\-
를 사용한다.
.PD
.PP
.B Bash
는 또한 여러 글자 옵션을 해석한다.  이 옵션을 인식시키려면 명령행에서 단일 글자
옵션보다 앞에 적어야 한다.
.PP
.PD 0
.TP 10
.B \-norc
쉘이 대화형 모드일 때
개인 초기화 파일인 
.I ~/.bashrc
실행하지 않도록 한다.
쉘을 실행할 때
.BR sh 
라는 이름으로 실행하면 기본적으로 이 옵션이 켜진다.
.TP
.B \-noprofile
시스템 전역 시동 파일
.FN /etc/profile
또는 
.IR ~/.bash_profile ,
.IR ~/.bash_login ,
.IR ~/.profile
와 같은 모든 개인 초기화 파일을 읽지 않도록 한다.
.B bash
가 로그인 쉘로 실행될 때에는 기본적으로 이 모든 파일을 읽는다.(
.SM
뒤에 나오는
.B INVOCATION
참고 ).
.TP
\fB\-rcfile\fP \fI파일\fP
쉘이 대화형 모드일 때(
.SM
.B INVOCATION
참고 )
표준적인 개인 초기화 파일인
.IR ~/.bashrc
대신
.I 파일
의 명령을 실행한다.
.TP
.B \-version
실행할 때
.B bash
의 버전 번호를 보여준다.
.TP
.B \-quiet
시작할 때 상세한 정보를 보여주지 않는다.(즉 쉘 버전과 기타 정보를 표시하지
않는다.)  기본값이다.
.TP
.B \-login
.B bash
가 마치 로그인 쉘로 시작된 것처럼 행동하게 한다.
.TP
.B \-nobraceexpansion
중괄호 확장을 하지 않는다.
( 뒤에 나오는
.B 중괄호(Brace) 확장
참고 ).
.TP
.B \-nolineediting
대화형 모드에서 명령을 읽을 때 GNU
.I readline
라이브러리를 사용하지 않는다.
.TP
.B \-posix
기본적으로 POSIX 1003.2 표준과 다른 bash의 행동 방식을 바꾸어 표준에 부합되도록
지시한다.
.PD
.SH 인수
옵션 처리 후 남은 인수가 있거나
.B \-c
또는
.B \-s
옵션이 없는 경우에는, 첫번째 인수를 쉘 명령을 포함하고 있는 파일 이름으로
간주한다.
.B bash
가 이런 방식을 실행되면,
is invoked in this fashion, 
.B $0
는 파일의 이름으로 설정되고 위치 매개변수는 남은 인수로 설정된다.
.B Bash
는 이 파일의 명령을 실행하고 종료한다.
스크립트에서 실행된 마지막 명령의 종료 상태가
.B Bash
의 종료 상태로 된다.
.SH 정의
.PD 0
.TP
.B 공백(blank)
스페이스 또는 탭.
.TP
.B 단어(word)
쉘에 의해 하나의 단위로 간주되는 연속된 문자들.
.BR 토큰(token)
이라고 부르기도 한다.
.TP
.B 이름(name)
알파벳, 숫자 문자와 언더스코어(_)로만 이루어져 있고 알파벳 문자와
언더스코어로 첫 문자를 시작하는
.I 단어
를 말한다.
.BR 식별자(identifier)
라고 부르기도 한다.
.TP
.B 메타문자(metacharacter)
쿼우트(quote) 처리하지 않을 때 단어을 구별하게 만드는 문자.
다음과 같다:
.br
.RS
.PP
.if t \fB|  &  ;  (  )  <  >  스페이스 탭\fP
.if n \fB|  & ; ( ) < > 스페이스 탭\fP
.RE
.PP
.TP
.B 제어 연산자(control operator)
제어 기능을 수행하는 \fI토큰\fP이다.  다음 기호에 해당한다:
.RS
.PP
.if t \fB\(bv\|\(bv  &  &&  ;  ;;  (  )  |  <newline>\fP
.if n \fB|| & && ; ;; ( ) | <newline>\fP
.RE
.PD
.SH "예약어(RESERVED WORDS)"
\fI예약어\fP란 쉘에 있어 특별한 의미를 갖는 단어를 말한다.
다음 단어는 쿼우트하지 않으면 예약어로 인식하거나 또는 간단한 명령의
첫번째 단어 또는
.B case 
나
.B for
명령의 세번째 단어로 인식한다:
( 
.SM
.B 쉘 문법
참고 )
.if t .RS
.PP
.B
.if n ! case  do done elif else esac fi for function if in select then until while { }
.if t !    case    do    done    elif    else    esac    fi    for    function    if    in    select    then    until    while    {    }
.if t .RE
.RE
.SH "쉘 문법(SHELL GRAMMAR)"
.SS 간단한 명령
.PP
\fI간단한 명령\fP이란 변수 지정(선택적, 역자 주: 원어로 optional이며
있어도 되고 없어도 된다는 의미로 사용한다.) 다음에 \fI공백\fP으로
구분된 단어와 리다이렉션이 뒤따르고 \fI제어 문자\fP로 끝나는 연속된
문자열을 말한다.  첫번째 단어는 실행할 명령이 된다.
나머지 단어는 실행 명령에 인수로 전달된다.
.PP
\fI간단한 명령\fP의 반환값은 종료 상태이거나 시그널
.IR n .
로 종료된 경우에는
128+\fIn\^\fP이 된다.
.SS 파이프라인
.PP
\fI파이프라인\fP이란 
.BR |
문자로 구분된 한 개 이상의 명령이 연속되어 나오는 것을 말한다.
파이프라인의 형식은 다음과 같다:
.RS
.PP
[ ! ] \fI명령\fP [ \fB|\fP \fI명령2\fP ... ]
.RE
.PP
.I 명령
의 표준 출력은 
.IR 명령2
의 표준 입력으로 연결된다.
파이프 라인 연결은 명령에서 명시한 리다이렉션 이전에 수행된다.
(
.SM
.B 리다이렉션
참고 ).
.PP
예약어인
.B !
가 파이프라인 앞에 나오면 파이프라인의 종료 상태값을 마지막 명령의
종료 상태에 대한 논리적인 NOT으로 설정한다.
그렇지 않은 일반적인 경우에는 마지막 명령의 종료 상태값이 파이프라인의
종료 상태값로 된다.
쉘은 값을 반환하기 전에 파이프라인에 연결되어 있는 모든 명령이 종료하기를
기다린다.
.PP
파이프라인의 각 명령은 개별적인 프로세스로 실행된다.(즉, 각자의 서브쉘
안에서 실행된다.)
.SS 리스트(Lists)
.PP
\fI리스트\fP란 한 개 이상의 파이프라인이 
.BR ; ,
.BR & ,
.BR && ,
.BR \(bv\|\(bv 
연산자 중 하나에 의해 구분되고
.BR ; ,
.BR & ,
.BR <개행문자>
중 하나로 끝나는 연속된 문자열을 말한다.
.PP
리스트 연산자 중에서,
.B &&
와
.B \(bv\|\(bv
는 같은 우선권을 가지고 있으며 그 다음으로
.B ;
와
.BR &
가 같은 우선권을 가지고 있다.
.PP
명령이 제어 연산자인
.BR & 
로 끝나면,
쉘은 그 명령을 서브쉘에서 \fI백그라운드\fP로 실행한다.
쉘은 명령이 종료하길 기다리지 않으면 반환값은 0 이다.
.B ;
로 구분된 명령들은 순차적으로 실행된다; 쉘은 차례대로 각 명령이
종료하기를 기다린다.  반환 상태값은 마지막으로 실행한 명령의 종료 상태값을
따른다.
.PP
제어 연산자
.B &&
와
.B \(bv\|\(bv
는 각각 AND 리스트와 OR 리스트를 나타낸다.
AND 리스트는 다음과 같은 형태를 가진다.
.RS
.PP
\fI명령\fP \fB&&\fP \fI명령2\fP
.RE
.PP
.I 명령2
는 
.I 명령
이 0 이라는 종료 상태값을 반환할 때에만 실행된다.
.PP
OR 리스트는 다음과 같은 형태를 가진다.
.RS
.PP
\fI명령\fP \fB\(bv\|\(bv\fP \fI명령2\fP
.PP
.RE
.PP
.I 명령2
는
.I 명령
의 종료 상태값이 0 이 아닌 값일 때에만 실행된다.
AND와 OR 리스트의 반환 상태값은 리스트에서 마지막으로 실행된 명령의
종료 상태값을 따른다.
.SS 복합 명령
.PP
\fI복합 명령\fP이란 다음 중 하나를 말한다:
.TP
(\fI리스트\fP)
\fI리스트\fP가 서브셀 안에서 실행된다.
명령이 완료된 후에는 쉘의 환경에 영향이 미치는 변수 지정과 내부 명령의
효과가 사라진다.
반환 상태값은
\fI리스트\fP
의 종료 상태값을 따른다.
.TP
{ \fI리스트\fP; }
\fI리스트\fP는 그냥 현재의 쉘 환경에서 실행된다.
known as a \fI그룹 명령\fP
이라고 부르기도 한다.
반환 상태값은
\fI리스트\fP
의 종료 상태값을 따른다.
.TP
\fBfor\fP \fI이름\fP [ \fBin\fP \fI단어\fP; ] \fBdo\fP \fI리스트\fP ; \fBdone\fP
\fBin\fP 다음의 단어 리스트가 확장되어 처리 항목 리스트를 생성한다.
\fI리스트\fP가 실행될 때마다 변수 \fI이름\fP에 리스트의 원소가 순서대로
설정된다. \fBin\fP \fI단어\fP가 생략되면 \fBfor\fP 명령은 설정된
각 위치 매개변수에 대하여 \fI리스트\fP를 한 번씩 실행한다.
(
.SM
.B PARAMETERS
참고 ).
.TP
\fBselect\fP \fI이름\fP [ \fBin\fP \fI단어\fP; ] \fBdo\fP \fI리스트\fP ; \fBdone\fP
\fBin\fP 다음의 단어 리스트가 확장되어 처리 항목 리스트를 생성한다.
확장된 단어 목록에 숫자를 붙여 표준 에러로 출력한다.
\fBin\fP \fI단어\fP가 생략되면 위치 매개변수를 출력한다.
(
.SM
.B PARAMETERS
참고 ).
.B PS3
프롬프트가 표시되고 표준 입력으로부터 한 줄을 입력받는다.
입력행의 내용에 표시된 단어 중 하나에 해당하는 숫자가 포함되어 있으면
.I 이름
은 그 단어로 설정된다.  빈 줄일 때에는 단어 리스트와 프롬프트가 다시
표시된다.  EOF를 만나면 명령이 종료한다.  
그 밖의 다른 값이 입력되면
.I 이름
이 널(null)로 설정된다.  읽어 들인 행은 변수
.BR REPLY 
에 저장된다.
.B break
또는
.B return
명령을 만나기 전까지 각각의 선택에 대하여
.I 리스트
가 실행된다.
.B select
의 종료 상태값은 
.IR 리스트
안에서 실행된 마지막 명령의 종료 상태값이거나
또는 아무 명령도 실행되지 않은 경우 0 이 된다.
.TP
\fBcase\fP \fI단어\fP \fBin\fP [ \fI패턴\fP [ \fB|\fP \fI패턴\fP ] \
... ) \fI리스트\fP ;; ] ... \fBesac\fP
\fBcase\fP 명령은 우선 \fI단어\fP를 확장한 다음, 
경로명 확장에서와 똑같은 일치 규칙을 사용하여
차례대로 \fI패턴\fP과의 매치를 시도한다.
(
.B Pathname Expansion
참고 ). 
일치하는 것이 발견되면 해당하는 \fI리스트\fP가 실행된다.
첫번째 일치 후에는 다음 일치 내용을 찾지 않는다.  아무 패턴과도 일치하지
않으면 0 이라는 종료 상태값을 갖는다.  일치하는 것이 있을 때에는
\fI리스트\fP에서 실행된 마지막 명령의 종료 상태값을 따른다.
.TP
\fBif\fP \fI리스트\fP \fBthen\fP \fI리스트\fP \
[ \fBelif\fP \fI리스트\fP \fBthen\fP \fI리스트\fP ] ... \
[ \fBelse\fP \fI리스트\fP ] \fBfi\fP
.B if 
.I 리스트
가 실행된다. 그 종료 상태값이 0 이면 \fBthen\fP \fI리스트\fP를
실행하고 명령을 마친다.
0 이 아니면 \fBelif\fP \fI리스트\fP가 있는 경우 이 부분을 실행한다.
종료 상태값은 마지막 실행 명령의 종료 상태값이 되거나 테스트한 조건이
하나도 참이 아닌 경우에는 0 이 된다.
.TP
.PD 0
\fBwhile\fP \fI리스트\fP \fBdo\fP \fI리스트\fP \fBdone\fP
.TP
\fBuntil\fP \fI리스트\fP \fBdo\fP \fI리스트\fP \fBdone\fP
.PD
\fBwhile\fP 명령은 
\fI리스트\fP의 마지막 명령 결과가 0 인 동안 \fBdo\fP \fI리스트\fP를
계속 실행한다. \fBuntil\fP 명령은 \fBwhile\fP 명령과 같으나 테스트 결과를
반대로 처리한다.
.B do
.I 리스트
는
.I 리스트
의 마지막 명령이 0 아닌 종료 상태값을 가지는 동안 실행된다.
\fBwhile\fP과 \fBuntil\fP 명령의 종료 상태값은 마지막 \fBdo\fP
\fI리스트\fP 명령의 상태 종료값을 따른다.  또는 아무 것도 실행되지
않은 경우 0 이 된다.
.TP
[ \fBfunction\fP ] \fI이름\fP () { \fI리스트\fP; }
\fI이름\fP의 함수를 정의한다.  함수의 \fI몸체\fP 부분은
{ 와 } 사이에 있는 명령
.I 리스트
이다.
간단한 명령의 이름으로 \fI이름\fP이 나올 때마다 이 리스트가 실행된다.
함수의 종료 상태값은 몸체 안에서 실행된 마지막 명령의 종료 상태값을
따른다.
(
.SM
.B FUNCTIONS
참고.)
.SH 주석(COMMENTS)
비\-대화형 쉘 또는 \fBset\fP 내부 기능을 작동하도록 하기 위해
.B -o interactive\-comments
옵션을 주어 실행한 대화형 쉘 안에서, 
.B #
로 시작하는 단어와 그 행의 모든 단어는 무시한다.
.B -o interactive\-comments
옵션 없이 대화형 쉘을 시작하면 주석을 사용할 수 없다.
.SH 쿼우팅(QUOTING)
\fI쿼우팅\fP은 쉘에 있어 특별한 의미를 갖는 문자나 단어의 그 의미를
제거할 때 사용한다.  또한 특수 문자에 대한 특별한 처리를 하지 못하게
하고 예약된 단어의 예약적 의미를 없애고 매개변수 확장을 하지 못하도록
할 때에도 쿼우팅을 사용한다.
(역자 주 : Quote에 대하여 여러 가지 한글 번역이 가능하겠으나 유닉스 쉘에서의
특별한 의미를 전달할 수 없다고 판단하여 그냥 발음나는 대로 쿼우트라고
번역하였다.)
.PP
.SM
.B DEFINITIONS
섹션에 나열한 \fI메타문자\fP 각각은 쉘에서 특별한 의미를 갖고 있기 때문에
글자 그대로를 표현하려면 쿼우트해야 한다.  3 가지 쿼우트 메커니즘이 있다:
.IR "이스케이프(escape) 문자" ,
싱글 쿼우트, 더블 쿼우트가 있다.
.PP
쿼우트하지 않은 백슬래쉬(\fB\e\fP)가
.IR "이스케이프 문자"
이다.
<개행문자>를 제외하고 이스케이프 문자는 그 다음에 뒤 따라 오는 문자의
글자 그대로의 의미를 보존한다.
\fB\e\fP<개행문자>가 나오고 백슬래쉬를 쿼우트하지 않았을 때에는
\fB\e\fP<개행문자>를 행 계속(역자 주 : 긴 명령을 한 줄에 적을 수 없을 때
행 끝에서 \fB\e\fP<개행문자>를 입력하면 다음 줄에 계속해서 입력할 수 있다)
을 뜻한다.(즉, 그 자체는 쉘에 의해 무시된다.)
.PP
싱글 쿼우트의 묶는 문자는 묶인 문자의 보이는 그대로의 값을 보존한다.
백슬래쉬를 앞에 적는다 해도 싱글 쿼우트 안에 싱글 쿼우트가 다시 들어
갈 수는 없다.
.PP
더블 쿼우트의 묶는 문자는 몇 가지 예외를 제외하고 쿼우트 안에 들어있는
모든 문자의 보이는 그대로의 의미를 보존한다.
.BR $ ,
.BR ` ,
와
.BR \e
는 예외의 경우이다.
.B $
와
.B `
문자는 더블 쿼우트 안에서도 특별한 의미를 유지한다.  백슬래쉬는
그 뒤에 다음 문자가 뒤따라 나올 때에만 특별한 의미를 갖는다:
.BR $ ,
.BR ` ,
\^\fB"\fP\^,
.BR \e ,
또는
.BR <개행문자> .
더블 쿼우트 안의 더블 쿼우트는 백슬래쉬를 사용하여 포함시킬 수 있다.
.PP
특별한 매개변수인
.B *
와
.B @
는 더블 쿼우트 안에서 특별한 의미를 지닌다.
(
.SM
.B PARAMETERS
참고 ).
.SH 매개변수(PARAMETERS)
.I 매개변수
란 값을 저장하는 개체로서 기존의 프로그램 언어에서의 변수와 어느 정도 비슷하다.
.IR 이름,
숫자, 또는 
.BR "특별한 매개변수(Special Parameters)"
섹션에서 나열한 특수 문자 중 하나가 될 수 있다.
쉘에 있어
.I 변수
란 
.IR 이름
으로 가리키는 매개변수이다.
.PP
값을 지정하면 매개변수가 설정된다.  널 문자열도 유효한 값으로 간주한다.
일단 변수가 설정되면 
.B unset
내부 명령을 통해서만 설정 해제할 수 있다.
(
.SM
.B 쉘 내부 명령(SHELL BUILTIN COMMANDS)
참고 ).
.PP
A
.I 변수
는 다음과 같은 문장을 통해 지정할 수 있다.
.RS
.PP
\fI이름\fP=[\fI값\fP]
.RE
.PP
If
.I 값
을 지정하지 않으면 변수는 널 문자열을 값으로 갖게 된다.
모든
.I 변수
는 틸드 확장, 매개변수와 변수 확장, 명령 치환, 연산에 의한 확장,
쿼우트 제거 등의 과정을 거친 다음, 그 결과를 저장한다.
변수의
.B \-i
속성이 설정되어 있는 상태라면
(
.SM
.BR "쉘 내부 명령"
섹션의
.B declare
참고
)
.I 값
은 $[...] 문법이 아니더라도 연산에 의한 확장을 거친다.
.BR "특별한 매개변수"
섹션에서 설명할 \fB"$@"\fP를 제외하고 단어 분리는 하지 않는다.
경로명 확장은 이루어지지 않는다.
.SS 위치 매개변수
.PP
.I 위치 매개변수
란 0 하나만 적는 것을 제외하고 숫자로 지시하는 매개변수를 말한다.
위치 매개변수는 쉘이 실행될 때 인수로부터 지정되거나
또는
.B set
내부 명령을 사용하여 재지정할 수 있다.
위치 매개변수는 변수 지정 문장을 사용하여 지정할 수 없다.
위치 매개변수는 쉘 함수가 실행될 때 일시적으로 치환된다.
(
.SM
.B 함수(FUNCTIONS)
참고 ).
.PP
1 개 이상의 숫자로 구성된 위치 매개변수를 확장할 때에는 중괄호로
묶어주어야 한다.
(
.SM
.B 확장(EXPANSION)
참고 ).
.SS 특별한 매개변수
.PP
쉘은 몇 가지 매개변수를 특별하게 처리한다.  이러한 매개변수는 참조만
가능할 뿐 값을 지정할 수는 없다.
.PD 0
.TP
.B *
1 부터 시작하여 위치 매개변수로 확장한다.  더블 쿼우트에서 확장이
이루어지면 각 매개변수 값을 한 단어로 확장한다.
각 단어는
.SM
.B IFS
특별 변수의 첫번째 문자로 구분한다.
다시 말해, ``\fB$*\fP'' 는
``\fB$1\fP\fIc\fP\fB$2\fP\fIc\fP\fB...\fP''
와 같다.
여기서
.I c
는
.SM
.B IFS
변수의 첫번째 문자이다.
.SM
.B IFS
가 널이거나 해제되어 있으며 매개변수는 스페이스로 구분한다.
.TP
.B @
1 부터 시작하여 위치 매개변수로 확장한다.  더블 쿼우트 안에서 확장이
이루어질 때에는 각 매개변수가 개별적인 단어로 확장한다.
즉 ``
.BR $@ ''
는
``\fB$1\fP'' ``\fB$2\fP'' ... 와 같다.
위치 매개변수가 없을 때에는
``\fB$@\fP'' 와
.B $@
은 아무 것으로도 확장되지 않는다.(즉, 없었던 것처럼 제거된다.)
.TP
.B #
십진수로 위치 매개변수의 갯수로 확장한다.
.TP
.B ?
최근에 실행된 포그라운드 파이프라인의 상태값으로 확장한다.
.TP
.B \-
실행하자마자 
.B set
내부 명령을 통해 또는 쉘 자체에 의해 (예를 들어
.B \-i
플래그) 설정된 현재 옵션 플래그로 확장한다.
.TP
.B $
쉘의 프로세스 ID로 확장한다.  () 서브쉘에서는 서브쉘이 아닌 현재 쉘의
프로세스 ID로 확장한다.
.TP
.B !
최근에 실행한 백그라운드(비동기) 명령의 프로세스 ID로 확장한다.
.TP
.B 0
쉘 또는 쉘 스크립트의 이름으로 확장한다.  쉘 초기화 과정 중에 설정된다.
.B bash
이 명령을 포함하는 파일 이름으로 실행되었다면,
.B $0
는 그 파일의 이름으로 설정된다.
.B bash
가
.B \-c
옵션을 가지고 실행되었다면
.B $0
는 실행될 문자열(있는 경우) 뒤 첫번째 인수로 설정된다.
그렇ㅈ 않은 경우
.BR bash
를 실행할 때 0 번 인수로 주어진 경로명으로 설정된다.
.TP
.B _
지난 번 명령의 마지막 인수(확장되고 난 형태)로 확장된다.
실행된 각 명령의 완전한 경로명으로도 설정되며 그 명령에게 export한
환경에 위치한다.
(역자 주 : 쉘의 용어에서 export의 마땅한 한글 번역을 찾지 못한 상태이다)
.PD
.SS 쉘 변수
.PP
다음 변수는 쉘에 의해 설정된다:
.PP
.PD 0
.TP
.B PPID
쉘의 부모 프로세스 ID.
.TP
.B PWD
.B cd
명령으로 설정된 현재 작업 디렉토리.
.TP
.B OLDPWD
.B cd
명령에 의해 설정되며 바로 이전 작업 디렉토리.
.TP
.B REPLY
인수가 제공되지 않은 경우
.B read
내부 명령으로 읽어 들인 입력 행으로 설정
.TP
.B UID
현재 사용자의 사용자 ID로 확장. 쉘 시동 시 초기화됨.
.TP
.B EUID
현재 사용자의 유효 사용자 ID로 확장. 쉘 시동 시 초기화됨.
.TP
.B BASH
현재 실행 중인
.BR bash
를 실행할 때 사용한 완전한 경로명으로 확장.
.TP
.B BASH_VERSION
현재 실행 중인
.BR bash 
인스턴스(instance)의 버전 번호로 확장.
.TP
.B SHLVL
.B bash
인스턴스를 실행할 때마다 1 씩 증가하는 변수
.TP
.B RANDOM
이 매개변수를 참조할 때마다 무작위 정수가 발생된다.
무작위 정수의 순서는 
.SM
.BR RANDOM
에 값을 지정하면 초기화된다.
If
.SM
.B RANDOM
를 unset하면 특별한 속성을 잃게 된다.  그 뒤에 다시 설정해도 잃은
속성은 돌아오지 않는다.
.TP
.B SECONDS
이 매개변수를 참조할 때마다 쉘이 시작한 시점부터 경과된 시간을 반환한다.
.SM
.BR SECONDS
에 값을 지정하면,
그 다음부터는 지정한 시점으로부터 경과한 시간 더하기 지정한 값이 반환된다.
.SM
.B SECONDS
를 unset 하면 특별한 속성을 잃게 된다. 그 뒤에 다시 설정해도 잃은
속성은 돌아오지 않는다.
.TP
.B LINENO
참조할 때마다 쉘은 이 변수를 스크립트 또는 함수 내에서의 지금 현재 시점에서의
순차적인 행 번호(1부터 시작)을 십진수로 치환해준다.
스크립트나 함수 안이 아닌 경우, 이 값은 의미가 없다.
함수 안에서의 값은 명령이 소스에서 위치하는 행 번호가 아니며
(이 정보는 함수가 실행될 때 사라진다.)
현재 함수 내에서 실행된
.I 간단한 명령
의 갯수에 대한 근사값이라고 생각하면 된다.
If
.SM
.B LINENO
를 unset 하면 특별한 속성을 잃게 된다. 그 뒤에 다시 설정해도 잃은
속성은 돌아오지 않는다.
.TP
.B HISTCMD
현재 명령의 히스토리 번호 또는 히스토리 리스트에서의 인덱스.
.SM
.B HISTCMD
를 unset 하면 특별한 속성을 잃게 된다. 그 뒤에 다시 설정해도 잃은
속성은 돌아오지 않는다.
.TP
.B OPTARG
.B getopts
내부 명령에 의해 처리된 마지막 옵션 인수의 값
(
.SM
.B 쉘 내부 명령
참고 ).
.TP
.B OPTIND
.B getopts
내부 명령에 의해 처리된 다음 인수의 인덱스
(
.SM
.B 쉘 내부 명령
참고 ).
.TP
.B HOSTTYPE
자동으로
.B bash
가 실행 중인 머신의 타입을 기술하는 고유한 문자열로 지정됨.
기본값은 시스템에 따라 다르다.
.TP
.B OSTYPE
자동으로
.B bash
가 실행 중인 운영체제의 타입을 기술하는 고유한 문자열로 지정됨.
기본값은 시스템에 따라 다르다.
.PD
.PP
다음 변수는 쉘에서 사용한다.
몇몇 경우
.B bash
는 변수에 기본값을 지정한다; 이런 경우에 대해서는 언급한다.
.PP
.PD 0
.TP
.B IFS
.I 내부 필드 구분자(Internal Field Separator)
는 확장 후에 단어를 분리하고 
.B read
내부 명령으로 읽은 행을 분리할 때 사용된다.
that is used
기본값은 ``<스페이스><탭><개행문자>''이다.
.TP
.B PATH
명령을 찾을 검색 경로이다.  쉘이 명령을 찾아 볼 디렉토리 목록을
콜론으로 구분하여 지정한다.
(
.SM
.B 명령 실행(COMMAND EXECUTION)
참고 ).
기본값은 시스템에 따라 다르며 관리
.BR bash
를 설치하는 관리자가 설정할 수 있다.
일반적으로 
``/usr/gnu/bin:/usr/local/bin: /usr/ucb:/bin:/usr/bin:'' 라는
값을 갖는다.
.TP
.B HOME
현재 사용자의 홈 디렉토리; 
\fBcd\fP 
내부 명령의 기본 인수이다.
.TP
.B CDPATH
.B cd
명령에서 사용하는 검색 경로.
.B cd
명령에서 사용한 목적지 디렉토리를 찾아 볼 디렉토리를 콜론으로 구분하여
적는다.  예를 들어
``.:~:/usr''와 같은 값으로 설정한다.
.TP
.B ENV
\fBbash\fP가 쉘 스크립트를 실행할 때 매개변수가 설정되어 있으면,
그 값은 
.IR .bashrc
와 같이 쉘을 초기화하는 명령을 담고 있는 파일의 이름으로 해석한다.
The value of
.SM
.B ENV
의 값은 경로명으로 해석되기 전에 매개변수 확장, 명령 치환, 연산 확장을
거쳐 설정된다.
결과로 나오는 경로명 검색에서
.SM
.B PATH
는 사용하지 않는다.
.TP
.B MAIL
이 매개변수가 파일 이름으로 설정되어 있고
.SM
.B MAILPATH
변수는 설정되어 있지 않으면,
.B bash
는 그 파일을 보고 메일의 도착 여부를 사용자에게 알려준다.
.TP
.B MAILCHECK
얼마나 자주(초 단위로)
.B bash
가 메일을 점검할 것인지 결정한다.
기본값은 60 초이다.  메일을 점검할 때가 되면 프롬프트를 보여 주기 전에
실행한다.
변수를 unset하면 메일 점검을 하지 않는다.
.TP
.B MAILPATH
메일이 왔는지 점검하기 위해 사용하는 경로명을 콜론으로 구분하여 설정한다.
출력할 메시지는 경로명 다음에 `?'를 적고 그 다음에 적어 설정할 수 있다.
$_ 는 현재 사용하고 있는 메일 파일의 이름을 표시한다.
예:
.RS
.PP
\fBMAILPATH\fP='/usr/spool/mail/bfox?"You have mail":~/shell-mail?"$_ has mail!"'
.PP
.B Bash
가 이 변수에 대한 기본값을 제공하지만 사용자 메일 파일의 위치는 시스템에
따라 다르다.
(예를 들어, /usr/spool/mail/\fB$USER\fP).
.RE
.TP
.B MAIL_WARNING
이 변수가 설정되어 있고 \fBbash\fP가 메일을 점검할 때 사용하는 파일을
지난 번 점검 시간 이후, 접근한 적이 있다면,
``The mail in \fI메일파일\fP has been read''라는 메시지가 출력된다.
.TP
.B PS1
이 매개변수의 값을 확장하여
(
.SM
.B PROMPTING
참고 )
주 프롬프트 문자열로 사용한다.  기본값은
``\fBbash\e$ \fP''이다.
.TP
.B PS2
이 매개변수의 값을 확장하여 2차 프롬프트 문자열로 사용한다.
기본값은 ``\fB> \fP''이다.
.TP
.B PS3
매개변수 값을 확장하여
.I select
명령의 프롬프트로 사용한다.
(앞서 나온
.SM
.B 쉘 문법
참고).
.TP
.B PS4
매개변수 값을 확장하여 실행 추적 중
.B bash
가 각 명령을 표시하기 전에 그 값을 사용한다.
.SM
.B PS4
의 첫번째 문자는 여러 레벨을 표시하기 위해 필요한 만큼 반복하여 표시한다.
기본값은 ``\fB+ \fP''.
.TP
.B HISTSIZE
명령 히스토리에서 기억해 둘 명령의 갯수
(
.SM
.B 히스토리(HISTORY)
참고 ) 기본값은 500.
.TP
.B HISTFILE
명령 히스토리를 저장할 파일 이름.
(
.SM
.B HISTORY
참고.) 기본값은 \fI~/.bash_history\fP.
unset 하면 대화형 쉘이 종료할 때 명령 히스토리를 저장하지 않는다.
.TP
.B HISTFILESIZE
히스토리 파일의 최대 행 갯수.  값을 지정하면 필요한 경우 그 값에 맞게 
파일을 잘라 쓴다(truncate).  기본값은 500.
.TP
.B OPTERR
1로 설정하면
.B bash
는
.B getopts
내부 명령에서 발생한 에러 메시지를 표시한다.
(
.SM
.B 쉘 내부 명령
참고).
쉘이 실행되거나 쉘 스크립트가 실행될 때
.SM
.B OPTERR
는 1로 초기화된다.
.TP
.B PROMPT_COMMAND
설정하면 주 프롬프트를 출력하기 전에 지정한 명령을 실행한다.
.TP
.B IGNOREEOF
입력행에
.SM
.B EOF
문자만 입력되었을 때 쉘이 어떤 행동을 보일 것인지 제어한다.
설정하면 값으로 지정한 횟수만큼
입력행의 처음에
.SM
.B EOF
문자가 연속적으로 입력될 때 
.B bash
가 종료한다.  변수는 존재하지만 숫자 값이 아니거나 아무런 값도 갖지 않을
때에는 기본값 10 을 사용한다.  존재하지 않으면
.SM
.B EOF
은 쉘에게 입력의 끝을 의미한다.  대화형 쉘에서만 효과를 지닌다.
.TP
.B TMOUT
0 보다 큰 값으로 설정하면 주 프롬프트가 표시된 후 설정한 값 만큼의 초를
기다린다.
그 동안 아무런 입력도 없으면
.B Bash
이 종료한다.
.TP
.B FCEDIT
.B fc
내부 명령의 기본 편집기.
.TP
.B FIGNORE
파일명 완성을 수행할 때 무시할 꼬리말의 목록을 콜론으로 구분하여 나열한다.
(
.SM
.B READLINE
참고)
.SM
.B FIGNORE
에 설정되어 있는 꼬리말을 가진 파일명은 일치하는 파일명 목록으로부터
제외된다.  예를 들어 ``.o:~''와 같은 값을 사용할 수 있다.
.TP
.B INPUTRC
기본값인
.FN ~/.inputrc
대신 readline 시동 파일로 사용할 파일명.
(
.SM
.B READLINE
참고).
.TP
.B notify
설정하면,
If set,
.B bash
는 종료된 백그라운드 작업에 대한 보고를 그 다음 주 프롬프트 표시 전까지
기다리지 않고 즉시 한다.
(
.B set
내부 명령의
.B \-b
옵션 참고)
.PD 0
.TP
.B history_control
.TP
.B HISTCONTROL
.PD
.IR ignorespace
라는 값으로 설정하면
.B 스페이스
문자로 시작하는 행은 히스토리 목록에 넣지 않는다.
.IR ignoredups
로 설정하면 마지막 히스토리 행과 일치하는 행은 히스토리 목록에 넣지 않는다.
.I ignoreboth
는 두 옵션을 합한 것과 같다.
unset하거나 위에서 말한 값이 아닌 값으로 설정하면 
파서(parser)에서 읽어 들인 모든 행을 히스토리 목록에 저장한다.
.TP
.B command_oriented_history
설정하면,
.B bash
는 여러 행으로 이루어진 명령의 모든 행을 똑같은 히스토리 항목으로 저장한다.
이렇게 하면 여러 행으로 이루어진 명령을 다시 편집할 때 편하다.
.TP
.B glob_dot_filenames
설정하면,
.B bash
경로명 확장의 결과에서 `.'로 시작하는 파일명도 포함시킨다.
.TP
.B allow_null_glob_expansion
설정하면,
.B bash
일치하는 파일이 없는 경로명 패턴을 그대로 놔두지 않고 널 문자열로
확장해준다.
(
.B 경로명 확장
참고)
.TP
.B histchars
히스토리 확장과 토큰화를 제어하는 둘 또는 세 개의 문자.
(
.SM
.B 히스토리 확장
참고)
첫번째 문자는
.IR "히스토리 확장 문자(history expansion character)"
로서, 즉 히스토리 확장의 시작을 알리는 문자이며 보통 `\fB!\fP 이다.
두번째 문자는
.IR "빠른 치환(quick substitution)"
문자로서 입력했던 이전 명령을 다시 실행하고 한 문자열을 명령의 다른 문자열로
치환하는데 사용하는 단축문자이다.
기본값은 `\fB^\fP' 이다.
선택적인 세번째 문자는 단어의 첫 문자로 사용할 때 행의 나머지 부분은
주석임을 알리는데 사용하는 문자로서, 보통 `\fB#\fP'를 사용한다.
히스토리 주석 문자를 사용하면 히스토리 치환를 할 때 행의 나머지 부분에
대하여 치환를 하지 않고 건너뛰도록 한다.
이 기능을 사용하기 위해 꼭 쉘 파서(parser)로 하여금 행의 나머지 부분을 주석으로
처리하도록 해 둘 필요는 없다.
.TP
.B nolinks
설정하면, 현재 작업 디렉토리를 변경하는 명령을 실행할 때 쉘이 심볼릭 링크는
따라가지 않도록 한다.  대신 물리적인 디렉토리 구조를 사용하도록 한다.
기본적으로
.B bash
는
.BR cd
와 같은 현재 디렉토리 변경 명령을 실행할 때 논리적인 디렉토리 사실을
따른다.
\fBset\fP
내부 명령의 \fB\-P\fP 옵션에 대한 설명을 참고하라.
(
.SM
.B 쉘 내부 명령
참고)
.PD 0
.TP
.B hostname_completion_file
.TP
.B HOSTFILE
.PD
.FN /etc/hosts
과 같은 형식의 파일로서 쉘이 호스트이름을 완성할 때 사용한다.
파일이름은 그 때 그 때 변경할 수 있다; 다음 번에 호스트이름 완성을
시도할 때
.B bash
는 새로운 파일의 내용을 기존 데이터베이스에 추가한다.
.TP
.B noclobber
설정하면,
.B bash
는
.BR > ,
.BR >& ,
.B <>
와 같은 리다이렉션 연산자로 기존의 파일을 덮어쓰지 않는다.
.B >
대신 
.B >|
리다이렉션 연산자를 사용하여 출력 파일을 만들 때에는 이 변수값에
상관없이 덮어쓴다.
(
.B set
내부 명령의 \fB\-C\fP 옵션에 대해서도 알아보라.)
.TP
.B auto_resume
쉘이 사용자와 작업 제어에 대한 상화 대화를 어떻게 할 것인지 제어한다.
변수를 설정하면, 리다이렉션을 사용하지 않은 단일 단어의 간단한 명령을
기존의 중단된 작업 재개를 위한 후보로 간주한다.
모호한 것은 허용되지 않는다; 입력한 문자열로 시작하는 작업이 여러 개일
때에는 최근에 접근한 적 있는 작업이 선택된다.
여기서 중단된 작업의
.I 이름
이란 작업을 시작했을 때 사용한 명령행을 말한다.
.IR exact
라는 값으로 설정하면,
입력한 문자열이 중단된 작업의 이름과 정확하게 일치해야 한다;
.IR substring
이라는 값으로 설정하면 ,
입력한 문자열이 중단된 작업 이름의 일부와 일치해도 된다;
.I substring
값은 
.B %?
job id
와 유사한 기능을 제공한다.
(
.SM
.B 작업 제어(JOB CONTROL)
참고 )
다른 값으로 설정하면 입력한 문자열은 중단된 작업 이름의 머리말이어야 한다;
.B %
job id
와 유사한 기능을 제공한다.
.TP
.B no_exit_on_failed_exec
이 변수를 설정하면, 
.B exec
내부 명령에서 주어진 파일을 실행할 수 없을 때에도 비대화형 쉘이
종료하지 않는다.
.B exec
에 실패할 때 대화형 쉘은 종료하지 않는다.
.TP
.B cdable_vars
이 변수를 설정하면
.B cd
내부 명령의 인수가 디렉토리가 아닐 때는, 이동하고자 하는 디렉토리를 값으로
갖고 있는 변수 이름으로 간주한다.
.PD
.SH 확장(EXPANSION)
확장은 명령행을 단어로 분리한 후 실행된다.
다음과 같은 몇 가지 확장이 수행된다:
.IR "중괄호 확장(brace expansion)" ,
.IR "틸드 확장(tilde expansion)" ,
.IR "매개변수와 변수 확장" ,
.IR "명령 치환" ,
.IR "연산 확장" ,
.IR "단어 분리" ,
.IR "경로명 확장" .
.PP
확장의 순서는 중괄호 확장, 틸드 확장, 매개변수, 변수, 명령 그리고
연산 치환(왼쪽에서 오른쪽 방향으로), 단어 분리, 경로명 확장 순이다.
.PP
이 기능을 지원하는 시스템에서는 \fI프로세스 치환(process substitution)\fP와
같은 추가 확장 기능이 있다.
.PP
중괄호 확장, 단어 분리, 경로명 확장만이 확장 시에 단어의 갯수를 변화시킬
수 있다; 다른 확장은 한 단어를 한 단어로 확장한다.
유일한 예외로는 앞서 설명한 바 있는 ``\fB$@\fP'' 확장을 들 수 있다.
(
.SM
.BR 매개변수
참고
).
.SS 중괄호 확장(Brace Expansion)
.PP
.I "중괄호 확장"
은 임의의 문자열을 생성시킬 수 있는 메커니즘이다.
이 메커니즘은 \fI경로명 확장\fP과 유사하지만 파일이름이 존재하지 않아도
된다는 점에서 다르다.  중괄호 확장할 패턴은 다음과 같은 형태를 띤다.
선택적인
.IR preamble
다음에 콤마로 구분된 문자열을 둘러 싼 중괄호가 나오고
선택적인
.IR postamble
이 따라 나온다.  preamble은 중괄호 안에 있는 각 문자열 앞에 추가되고
postamble은 왼쪽에서 오른쪽으로 각각의 결과 문자열 뒤에 추가된다.
.PP
중괄호 확장은 중첩할 수 있다.  확장된 각 문자열의 결과는 정렬되지 않는다;
왼쪽에서 오른쪽으로라는 순서는 보존된다.
예를 들어 a\fB{\fPd,c,b\fB}\fPe는 `ade ace abe'로 확장된다.
.PP
중괄호 확장은 다른 확장보다 먼저 수행되며 다른 확장에 특별한 의미를 갖는
문자열은 보존된다.  중괄호 확장은 엄격하게 글자 그대로 이루어진다.
.B Bash
는 확장 상황이나 중괄호 안의 텍스트에 대하여 문법적인 해석을 시도하지
않는다.
.PP
올바른 형식의 중괄호 확장에는 쿼우트하지 않은 상태로 여는 중괄호, 닫는
중괄호가 있고 역시 쿼우트하지 않은 하나 이상의 콤마가 포함된다.
올바르지 않은 형태의 중괄호 확장은 그대로 놔둔다.
.PP
중괄호 확장 형식은 보통 다음 예에서처럼 문자열의 공통 머리말 부분이 훨씬
긴 경우 짧게 축약하기 위해 사용된다:
.RS
.PP
mkdir /usr/local/src/bash/{old,new,dist,bugs}
.RE
또는
.RS
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
.RE
.PP
중괄호 확장은 
전통적인 버전의
.BR sh ,
본쉘(Bourne shell)과 약간의 비호환성을 가져왔다.
.B sh
는 중괄호가 단어의 일부로 나타날 때 특별하게 처리하지 않고 그대로 보존하여
출력한다.
.B Bash
는 단어로부터 중괄호를 제거하고 중괄호 확장을 한다.
예를 들어
.B sh
에서
\fIfile{1,2}\fP는 출력에서도 그대로 \fIfile{1,2}\fP 이다.
.BR bash
에서는 같은 단어에 대하여 중괄호 확장을 하여
.I file1 file
로 보여준다.
만약
.B sh
과의 철저한 호환성을 원할 때에는
.B bash
를 시작할 때 
.B \-nobraceexpansion
플래그를 붙여 실행하라.
.B \-nobraceexpansion
( 앞서 나온
.SM
.B 옵션
참고 )
또는 
.B set
명령에서 
.B +o braceexpand
옵션을 주어 중괄호 확장 기능을 해제할 수 있다.
(
.SM
.B 쉘 내부 명령
참고 )
.SS 틸드 확장(Tilde Expansion)
.PP
단어가 틸드 문자(`\fB~\fP')로 시작하면, 첫번째 슬래쉬 앞에 있는 모든
문자(또는 슬래쉬가 없는 경우에는 모든 문자)는 가능한 \fI로그인 이름\fP으로
간주한다.  \fI로그인 이름\fP이 널 문자열인 경우에는 
.SM
.BR HOME
매개변수의 값으로 틸드를 치환한다.
.SM
.B HOME
가 설정되어 있지 않을 때에는 쉘을 실행 중인 사용자의 홈 디렉토리로 대신
치환한다.
.PP
틸드 다음에 `+'가 뒤따르면, 틸드와 `+'를
.SM
.B PWD
의 값으로 치환한다.
`\-'이 오는 경우에는
.SM
.B OLDPWD
변수 값으로 치환된다.
틸드 다음에 나오는 값이 유효한 \fI로그인 이름\fP일 때에는 틸드와
\fI로그인 이름\fP을 그 이름을 갖는 사용자의 홈 디렉토리로 치환한다.
이름이 유효하지 않을 때에는 틸드 확장이 실패할 것이며 그 때에는 단어를
그대로 놔둔다.
.PP
변수 지정을 시행할 때마다
.B :
또는
.BR =
다음에 나오는 쿼우트하지 않은 틸드를 점검한다.
이 경우 틸드 확장이 시행된다.  따라서 
.SM
.BR PATH ,
.SM
.BR MAILPATH ,
.SM
.BR CDPATH
지정에서 틸드와 함께 경로명을 사용할 수 있으며 쉘은 그 확장된 값을
지정해준다.
.SS 매개변수 확장(Parameter Expansion)
.PP
`\fB$\fP' 문자는 매개변수 확장, 명령 치환, 연산 확장을 시행하도록 한다.
확장할 매개변수 이름 또는 기호는 중괄호로 둘러 쌀 수도 있다.
확장할 변수 뒤에 따라 오는 문자들을 이름의 일부로 해석하지 않도록 보호할
때 사용한다.
.PP
.PD 0
.TP
${\fI매개변수\fP}
\fI매개변수\fP의 값으로 치환된다.
.I 매개변수
가 한 개 이상의 숫자로 된 위치 매개변수이거나,
.I 매개변수
다음에 문자열로 함께 해석하지 않아야 할 문자가 뒤따라 나오는 경우에는
중괄호가 필요하다.
.PD
.PP
아래의 모든 경우에서, \fI단어\fP에 대하여 틸드 확장, 매개변수 확장, 명령 치환,
연산 치환가 시행된다.
\fBBash\fP
매개변수가 unset 상태인지 널인지 점검한다;
콜론을 빼면 unset 상태의 매개변수에 대한 점검만 행한다.
.PP
.PD 0
.TP
${\fI매개변수\fP\fB:\-\fP\fI단어\fP}
\fB기본값 사용\fP.  If
.I 매개변수
가 unset 되어 있거나 널이면,
.I 단어
의 확장으로 치환된다.  그렇지 않을 때에는
.I 매개변수
의 값으로 치환된다.
.TP
${\fI매개변수\fP\fB:=\fP\fI단어\fP}
\fB기본값을 지정\fP.
.I 매개변수
가 unset 되어 있거나 널이면,
.I 단어
의 확장이
.IR 매개변수
로 지정된다.
그러면
.I 매개변수
의 값 자체가 치환된다.
위치 매개변수와 특별한 매개변수는 이런 방식으로 지정할 수 없을 것이다.
.TP
${\fI매개변수\fP\fB:?\fP\fI단어\fP}
\fB널이거나 unset 이면 에러를 출력한다\fP.
If
.I 매개변수
가 널이거나 unset 상태면, \fI단어\fP의 확장(또는 
.I 단어
가 존재하지 않으면 그에 대한 메시지)
이 표준 에러와 쉘에 출력하고 대화형 모드가 아닐 때에는 종료한다.
그렇지 않으면 \fI매개변수\fP의 값이 치환된다.
.TP
${\fI매개변수\fP\fB:+\fP\fI단어\fP}
\fB다른 값 사용하기\fP.
.I 매개변수
가 널이거나 unset 이면, 아무 것도 치환되지 않고 그렇지 않으면
.I 단어
의 확장으로 치환된다.
.TP
${\fB#\fP\fI매개변수\fP}
\fI매개변수\fP의 값으로 들어있는 문자열의 길이로 치환한다.
\fI매개변수\fP가
.B *
이거나
.BR @
일 때에는, 더블 쿼우트 안에서
.B *
이 확장되었을 때의 길이로 치환한다.
.TP
.PD 0
${\fI매개변수\fP\fB#\fP\fI단어\fP}
.TP
${\fI매개변수\fP\fB##\fP\fI단어\fP}
.PD
경로명 확장에서처럼 패턴을 만들기 위해 
.I 단어
가 확장된다.
만약 패턴이
.IR 매개변수
값의 첫 부분과 일치하면,
.I 매개변수
값에서
가장 짧은 일치가 일어나는 패턴 내용을 삭제한 값
(``\fB#\fP''의 경우) 또는
가장 긴 일치가 일어나는 패턴을 삭제한 값
(``\fB##\fP''의 경우)으로 확장한다.
.TP
.PD 0
${\fI매개변수\fP\fB%\fP\fI단어\fP}
.TP
${\fI매개변수\fP\fB%%\fP\fI단어\fP}
.PD
경로명 확장에서처럼 패턴을 만들기 위해 
.I 단어
가 확장된다.
만약 패턴이
.IR 매개변수
값의 뒷 부분과 일치하면,
.I 매개변수
값에서
가장 짧은 일치가 일어나는 패턴 내용을 삭제한 값
(``\fB%\fP''의 경우) 또는
가장 긴 일치가 일어나는 패턴을 삭제한 값
(``\fB%%\fP''의 경우)으로 확장한다.
.SS 명령 치환
.PP
\fI명령 치환\fP을 사용하여 명령 이름을 명령의 출력 결과로 치환할 수 있다.
다음 두 가지 형태를 가지고 있다:
.PP
.RS
.PP
\fB$(\fP\fI명령\fP\|\fB)\fP
.RE
또는
.RS
\fB`\fP\fI명령\fP\fB`\fP
.RE
.PP
. B Bash
는 \fI명령\fP을 실행하고 그 명령의 표준 출력으로 명령 치환을 교체하는 방식으로
확장을 실행한다.  표준 출력에서 뒷 부분의 개행문자는 삭제한다.
.PP
구식 백쿼우트 형식을 사용할 때, 백슬래쉬는 그 뒤에
.BR $ ,
.BR ` ,
.BR \e
이 따라오는 경우를 제외하고는 글자 그대로의 의미를 유지한다.
$(\^\fI명령\fP\|) 형식을 사용할 때에는 괄호 사이에 있는 모든 글자가
명령을 구성한다; 어느 문자도 특별하게 취급받지 않는다.
.PP
명령 치환은 중첩할 수 있다. 구식 형태에서 중첩을 하려면 내부의 백쿼우트를
백슬래쉬로 해석금지시켜야 한다.
.PP
더블 쿼우트 안에서 치환이 일어나면 결과에 대하여 단어 분리, 경로명 확장은
시행되지 않는다.
.SS 연산 확장
.PP
연산 확장을 사용하여 연산식을 계산하고 그 결과 값으로 치환할 수 있다.
연산 확장에는 두 가지 형식이 있다:
.RS
.PP
\fB$[\fP\fI표현식\fP\fB]\fP
.PP
\fB$((\fP\fI표현식\fP\fB))\fP
.RE
.PP
The
.I 표현식
은 더블 쿼우트 안에 있는 것처럼 취급한다.  그러나 중괄호와 괄호 안에
놓인 더블 쿼우트는 특별하게 대우하지 않는다.  표현식 안에 있는 모든 토큰은
매개변수 확장, 명령 치환, 쿼우트 제거 과정을 거친다.
연산 치환은 중첩 가능하다.
.PP
평가 작업은 
뒤에 나올
.SM
.BR "연산 평가(ARITHMETIC EVALUATION)"
에서 나열한 규칙에 따라 시행된다.
.I 표현식
이 유효하지 않을 때
.B bash
는 실패를 뜻하는 메시지를 출력하고 더 이상 치환을 하지 않는다.
.SS 프로세스 치환
.PP
\fI프로세스 치환\fP은 명명된 파이프(\fIFIFOs\fP) 또는 오픈한 파일을 명명하는
\fB/dev/fd\fP 방식을 갖고 있는 시스템에서 지원된다.
\fB<(\fP\fI리스트\^\fP\fB)\fP
또는
\fB>(\fP\fI리스트\^\fP\fB)\fP의 형식을 띤다.
프로세스 \fI리스트\fP는 입력 또는 출력을 \fIFIFO\fP 또는 \fB/dev/fd\fP의 
파일에 연결하여 실행한다.  확장의 결과로 이 파일의 이름이 현재 명령의
인수로 전달된다. \fB>(\fP\fI리스트\^\fP\fB)\fP 형식을 사용하면
파일에 쓰는 내용이 \fI리스트\fP에 대한 입력이 된다.
\fB<(\fP\fI리스트\^\fP\fB)\fP 형식을 사용하면 \fI리스트\fP의 출력을
얻기 위해 인수로 전달된 파일을 읽을 수 있어야 한다.
.PP
이를 지원하는 시스템에서 \fI프로세스 치환\fP은 
.IR "매개변수와 변수 확장" ,
.IR "명령 치환" ,
.IR "연산 확장"
과 동시에 일어난다.
.SS 단어 분리
.PP
쉘은
.IR "단어 분리"
를 위하여 더블 쿼우트 안에서 일어나지 않은
매개변수 확장, 명령 치환, 연산 확장의 결과를 조사한다.
.PP
쉘은
.SM
.B IFS
값으로 들어있는 각 글자를 구분자(delimeter)로 사용하여 다른 확장의
결과를 단어로 분리한다.
.SM
.B IFS
의 값이 정확히
.BR <스페이스><탭><개행문자>
즉 기본값이라면,
.SM
.B IFS
문자의 어떠한 조합도 단어를 구분하게 해준다.
.SM
.B IFS
의 값이 기본값 아닌 값을 가지고 있는 경우에는, 화이트스페이스 문자가
.SM
.BR IFS
값에 포함되어 있는 한, 단어의 앞뒤에 오는 화이트스페이스 문자
.B 스페이스
와
.B 탭
을 무시한다.
.SM
.BR IFS
(
.SM
.B IFS
화이트스페이스 문자).
.SM
.B IFS
화이트스페이스가 아닌 
.SM
.B IFS
속의 모든 문자와 인접한
.SM
.B IFS
화이트스페이스 문자는 하나의 필드로 구분한다.
.SM
.B IFS
화이트스페이스 문자의 연속도 구분자로 간주한다.
.SM
.B IFS
값이 널이면 단어 분리는 일어나지 않는다.
.SM
.B IFS
는 unset 할 수 없다.
.PP
명시적인 널 인수는 (\^\f3"\^"\fP 또는 \^\f3'\^'\fP\^) 그대로 유지한다.
.I 매개변수
의 확장 결과 만들어지는 널 인수는 제거된다.
.PP
확장이 일어나지 않은 경우에는 단어 분리도 일어나지 않는다는 사실을
잘 알아두어야 한다.
.SS 경로명 확장
.PP
단어 분리 후에는
.B \-f
옵션이 설정되어 있지 않는 한,
.B bash
는 
.I 단어
를 검색하면서
.BR * ,
.BR ? ,
.BR [
문자를 찾는다.
이러한 문자 중 하나가 나타나면 그 단어는 
.IR 패턴
으로 간주하고 패턴과 일치하는 경로명을 알파벳 순으로 정렬한 리스트로
치환한다.  일치하는 경로명이 발견되지 않고
쉘 변수
.B allow_null_glob_expansion
가 unset되어 있으면 단어를 변경하지 않고 그대로 놔둔다.
이 변수가 설정되어 있기는 하지만 일치하는 것이 없다면, 단어를 제거한다.
경로명 생성 시에 패턴이 사용될 때,
이름의 시작 부분 또는 슬래쉬 바로 다음에 나오는
.B ``.''
문자에 대해서는 쉘 변수
.B glob_dot_filenames
가 설정되어 있지 않은 한, 명시적인 일치가 이루어져야 한다.
슬래쉬 문자는 항상 명시적인 일치여야 한다.
다른 경우
.B ``.''
문자는 특별하게 취급하지 않는다.
.PP
특수한 패턴 문자는 다음과 같은 의미를 지닌다:
.PP
.PD 0
.TP
.B *
널 문자열을 포함한 모든 문자열과 일치한다.
.TP
.B ?
모든 단일 문자와 일치한다.
.TP
.B [...]
대괄호 안의 어떤 문자와도 일치한다.  문자 가운데 마이너스 부호가 있는
경우에는
.IR 범위
를 뜻한다;
두 문자 사이의 사전적 순서에 의거하여 위치하는 모든 문자(두 문자 포함)에
대하여 일치가 일어난다.
.B [
다음에 나오는 첫번째 문자가
.B !
이거나
.B ^
이면 괄호 안에 있는 모든 문자에 대하여 일치가 일어나지 않는다.
.B \-
또는
.B ]
에 대하여 일치를 시키려면 괄호 안에서 첫번째 또는 마지막 문자로
포함시키면 된다.
.PD
.SS 쿼우트 제거
.PP
앞서 말한 확장이 일어난 후, 쿼우트하지 않은 모든
.BR \e ,
.BR ` ,
\^\f3"\fP\^
문자는 제거한다.
.SH 리다이렉션(REDIRECTION)
명령이 실행되기에 앞서 쉘에 의해 특별하게 해석되는 표시를 사용하여
입력과 출력을
.I 방향 전환
또는
.I 리다이렉트
할 수 있다.
현재 쉘 실행 환경에 대하여 파일을 열고 닫는 용도로 리다이렉션을 사용할
수도 있다.
다음에 나오는 리다이렉션 연산자는 
.I 간단한 명령
의 앞 또는 중간에 오거나
.IR 명령
의 뒤에 온다.
리다이렉션은 왼쪽부터 오른족으로 나타난 순서대로 처리한다.
.PP
다음 설명에 있어 파일 기술자 번호가 생략되어 있고 리다이렉션 연산자의
첫번째 문자가
.BR <
이면 이 리다이렉션은 표준 입력(파일 기술자 0 번)을 가리킨다.
리다이렉션 연산자의 첫번째 문자가
.BR >
이면 이 리다이렉션은 표준 출력(파일 기술자 1 번)을 가리킨다.
.PP
리다이렉션 연산자 다음에 나오는 단어는 중괄호 확장, 틸드 확장,
매개변수 확장, 명령 치환, 연산 확장, 쿼우트 제거, 경로명 확장을
거친다.  한 개 이상의 단어로 확장될 때에는
.B bash
가 에러를 보고한다.
.PP
리다이렉션의 순서가 매우 중요하다.  예를 들어, 다음 명령
.RS
.PP
ls \fB>\fP dirlist 2\fB>&\fP1
.RE
.PP
는 표준 출력과 표준 에러 모두 
.IR dirlist
파일로 보내지만 다음 명령
.RS
.PP
ls 2\fB>&\fP1 \fB>\fP dirlist
.RE
.PP
오로지 표준 출력만 
.IR dirlist
파일로 보낸다. 왜냐하면 표준 출력이
.IR dirlist
파일로 방향 전환되기 전에 표준 에러가 표준 출력으로 복제되었기 때문이다.
.SS 입력 리다이렉션
.PP
입력 리다이렉션은 파일 기술자
.IR n
또는
.IR n
이 생략된 경우 표준 입력 (파일 기술자 0)으로 읽기 위해
.I 단어
를 확장하여 나온 이름의 파일을 오픈하게 만든다.
.PP
입력 리다이렉션의 일반적인 형식은 다음과 같다:
.RS
.PP
[\fIn\fP]\fB<\fP\fI단어\fP
.RE
.SS 출력 리다이렉션
.PP
출력 리다이렉션은 파일 기술자
.IR n
또는
.IR n
이 생략된 경우 표준 출력 (파일 기술자 1)으로 쓰기 위해
.I 단어
를 확장하여 나온 이름의 파일을 오픈하게 만든다.
.PP
출력 리다이렉션의 일반적인 형식은 다음과 같다:
.RS
.PP
[\fIn\fP]\fB>\fP\fI단어\fP
.RE
.PP
리다이렉션 연산자를
.BR >| 
와 같이 적으면,
.B set
내부 명령에 대한
.B -C
옵션 값을 점검하지 않고 파일 생성을 시도한다.
( 위에서 나온
.B "쉘 변수"
섹션의
.B noclobber
설명을 참고 )
.SS 추가 출력 리다이렉션
.PP
추가 출력 리다이렉션은 파일 기술자
.IR n
또는
.IR n
이 생략된 경우 표준 출력 (파일 기술자 1)으로 추가하기 위해
.I 단어
를 확장하여 나온 이름의 파일을 오픈하게 만든다.
파일이 존재하지 않으면 생성한다.
.PP
출력 추가하기의 일반적인 형식은 다음과 같다:
.RS
.PP
[\fIn\fP]\fB>>\fP\fI단어\fP
.RE
.PP
.SS 표준 출력과 표준 에러 리다이렉션
.PP
.B Bash
는 지금 설명할 표기법을 사용하여
표준 출력(파일 기술자 1)과 표준 에러 출력(파일 기술자 2) 둘 다
.I 단어
의 확장 결과 나오는 이름의 파일로 방향전화시킬 수 있다.
.PP
표준 출력과 표준 에러를 동시에 리다이렉트하는 두 가지 형식이 있다:
.RS
.PP
\fB&>\fP\fI단어\fP
.RE
and
.RS
\fB>&\fP\fI단어\fP
.RE
.PP
두 가지 형식 중 첫번째 것을 선호한다.
Of the two forms, the first is preferred.
위 형식은 다음과 문법적으로 동일하다.
.RS
.PP
\fB>\fP\fI단어\fP 2\fB>&\fP1
.RE
.SS HERE 문서
.PP
이 유형의 리다이렉션은 쉘로 하여금 자신의 현재 소스로부터
.I 단어
(뒤에 공백이 없이)
만 나오는 줄이 나올 때가지 입력으로 읽어들이도록 지시한다.
이 지점까지의 모든 행은 명령에 대한 표준 입력으로 사용된다.
.PP
HERE 문서의 형식은 다음과 같다:
.RS
.PP
.nf
\fB<<\fP[\fB\-\fP]\fI단어\fP
        \fIHERE\-문서\fP
\fI구분자\fP
.fi
.RE
.PP
.IR 단어
에 대해서는 어떠한 매개변수 확장, 명령 치환, 경로명 확장, 또는
연산 확장도 시행되지 않는다.
.I 단어
안의 문자에 대하여 쿼우트된 것이 있다면
.I 구분자
는 
.IR 단어
로부터 쿼우트를 제거한 결과이며 HERE 문서의 행은 확장되지 않는다.
그렇지 않을 때에는 HERE 문서의 모든 행에 대하여 매개변수 확장, 명령 치환,
연산 치환이 시행된다.  후자의 경우,
.B \e<개행문자>
는 무시하며
.BR \e ,
.BR $ ,
.BR `
문자를 쿼우트할 때에는
.B \e
를 사용한다.
.PP
리다이렉션 연산자가
.BR <<\- 
라면,
입력행과
.IR 구분자
를 포함하는 행에서 앞에 나오는 모든 탭 문자를 제거한다.
이 기능을 사용하면 쉘 스크립트 내부의 HERE 문서에서도 자연스럽게
들여쓰기를 사용할 수 있다.
.SS "파일 기술자 복제하기"
.PP
다음 리다이렉션 연산자
.RS
.PP
[\fIn\fP]\fB<&\fP\fI단어\fP
.RE
.PP
는 입력 파일 기술자를 복제할 때 사용한다.
.I 단어
가 한 개 이상의 숫자로 확장되면, 
.I n
이 가리키는 파일 기술자는 그 파일 기술자의 복사본이 된다.
만약
.I 단어
의 결과가
.BR \-
라면 ,
파일 기술자
.I n
은 닫힌다.
.I n
를 명시하지 않으면, 표준 입력(파일 기술자 0)을 사용한다.
.PP
다음 연산자
.RS
.PP
[\fIn\fP]\fB>&\fP\fI단어\fP
.RE
.PP
는 마찬가지로 출력 파일 기술자를 복제할 때 사용한다.
.I n
이 생략되어 있으면 표준 출력(파일 기술자 1)이 사용된다.
특별한 경우로서, \fIn\fP이 생략되어 있고 \fI단어\fP가 한 개 이상의
숫자로 확장되지 않을 때에는 앞에서 설명한 것처럼 표준 출력과 표준 에러가
리다이렉트된다.
.SS "읽기 쓰기를 위해 파일 기술자 열기"
.PP
다음 리다이렉션 연산자
.RS
.PP
[\fIn\fP]\fB<>\fP\fI단어\fP
.RE
.PP
는
읽기와 쓰기를 위해
파일 기술자
.IR n
또는
.IR n
이 생략된 경우 표준 입력과 표준 출력으로 
.I 단어
의 확장 결과로 나오는 이름을 가진 파일을 오픈하도록 한다.
파일이 존재하지 않는 경우 생성된다.
.SH 함수(FUNCTIONS)
앞서 나온
.SM
.BR "쉘 문법"
섹션에서 정의한 바 있는 쉘 함수는 이후의 실행을 위해 명령의 나열을
저장해둔다.  함수는 현재 쉘 상황에서 실행된다;  함수를 해석하기 위해
새로운 프로세스가 만들어지지는 않는다.(이는 쉘 스크립트 실행과 대조적이다.)
함수가 실행되면 실행 중에는 함수에 대한 인수가 위치 매개변수로 바뀐다.
특별한 매개변수인
.B #
는 이 변화를 반영하기 위해 갱신된다.  위치 매개변수 0 은 바뀌지 않는다.
.PP
함수에 지역적인 변수는 내부 명령
.B local
을 사용하여 선언할 수 있다.  보통은 변수와 그 값은 함수와 호출한 자가
공유한다.
.PP
내부 명령
.B return
이 함수 안에서 실행되면 함수는 실행을 완료하고 함수 호출 바로 다음부터
실행이 재개된다.  함수 실행이 완료되면 위치 매개변수와 특별한 매개변수
.B #
의 값이 함수 호출 이전 상태로 복원된다.
.PP
함수 이름과 정의는 내부 명령
.B declare
또는
.B typeset
명령에
.B \-f
옵션을 주어 나열할 수 있다.
내부 명령
.B export
에
.B \-f
옵션을 주면 서브쉘에서도 자동으로 정의되도록 함수를 export할 수 있다.
.PP
함수는 재귀 호출할 수 있다.  재귀 호출의 횟수에 대한 제한 사항은 없다.
.SH 앨리어스 또는 별칭(ALIASES)
쉘은 내부 명령
.B alias
와
.B unalias
로 설정하고 해제할 수 있는
.I 앨리어스(aliases)
목록을 관리한다.
(
.SM
.B 쉘 내부 명령
참고 ).
쿼우트하지 않은 각 명령의 첫번째 단어에 대해서는 앨리어스가 있는지
점검한다.  앨리어스가 있으면 그 단어는 앨리어스의 텍스트 내용으로 치환된다.
앨리어스 이름과 치환 텍스트는
.I 메타문자
를 포함하여 유효한 쉘 입력을 포함할 수 있다.  그러나 예외적으로 앨리어스 이름에
\fI=\fP를 포함할 수 없다.
치환 텍스트의 첫번째 단어에 대하여 앨리어스가 있는지 점검한다.  그러나
확장하려는 앨리어스와 똑같은 단어는 두 번 확장하지 않는다.
즉, 다음과 같이 
.B ls
의 앨리어스를 다음과 같이
.BR "ls \-F"
라고 정의할 수 있으며
.B bash
는 치환 텍스트를 회귀적으로 확장하려 하지 않는다.
앨리어스 값의 마지막 문자가
.IR 공백
이면,
앨리어스 다음에 나오는 명령 단어에 대해서도 앨리어스 확장 여부를 점검한다.
.PP
앨리어스는
.B alias
명령을 사용하여 만들고 열거하며
.B unalias
명령을 사용하여 제거한다.
.PP
.BR csh
에서처럼 치환 텍스트에서 인수를 사용하게 해주는 메커니즘은 없다.
인수가 필요할 때에는 쉘 함수를 사용해야 한다.
.PP
쉘이 대화형 모드가 아닐 때에는 앨리어스를 확장하지 않는다.
.PP
앨리어스의 정의와 사용법에 대한 규칙은 약간 혼란스럽다.
.B Bash
는 항상 어떤 행에 존재하는 명령을 실행하기에 앞서 최소한 완전한
한 행을 읽는다.  앨리어스를 실행할 때가 아니라 명령을 읽어들일 때 확장된다.
따라서, 다른 명령과 같은 행에 나타나는 앨리어스 정의는 다음 행을 읽을 때까지
효력을 발휘하지 않는다.  같은 행에서 앨리어스 정의 다음에 나오는 명령은
새로운 앨리어스의 영향을 받지 않는다.  이 행동 방식은 함수가 실행될 때에도
문제가 된다.  함수 정의 자체가 복합 명령이기 때문에 함수를 실행할 때가 아니라
함수 정의를 읽을 때 앨리어스를 확장한다.  결과적으로 함수 안에 정의된
앨리어스는 다른 함수를 실행하기 전까지는 사용되지 않는다.
안전하게 하기 위해 앨리어스 정의는 항상 개별적인 행에 적고 복합 명령에서는
.B 앨리어스
를 사용하지 말라.
.PP
거의 모든 용도에서 앨리어스 대신 함수를 사용하는 것이 좋다는 점을 기억하라.
.SH "작업 제어(JOB CONTROL)"
.I 작업 제어
란 선택적으로 프로세스의 실행을 멈추고 (\fI일시 중지(suspend)\fP)
나중에 중단된 실행을 계속하도록 할 수 있는 (\fI작업 재개(resume)\fP) 기능을
말한다.  사용자는 일반적으로 시스템의 터미널 드라이버와
.BR bash
에서 제공하는 대화형 인터페이스를 통해 이 기능을 사용한다.
.PP
쉘은 각 파이프라인에
.I 작업
을 연관시킨다.  쉘은 현재 실행 중인 작업 도표를 지니고 있으며
.B jobs
명령을 사용하여 나열해 볼 수 있다.
.B bash
가 작업을 비동기적으로 (
.IR 백그라운드
로) 시작할 때는,
다음과 유사한 행을 출력한다:
.RS
.PP
[1] 25647
.RE
.PP
이 작업의 작업 번호가 1 이며 이 작업과 연관된 파이프라인의 마지막 프로세스의
프로세스 ID가 25647 이라는 사실을 알려준다.
.B Bash
는 작업 제어를 위해 그 기초로서
.I 작업
추상화를 사용한다.
.PP
작업 제어에 대한 사용자 인터페이스를 구현을 할 수 있도록 시스템에서는
\fI현재 터미널 프로세스 그룹 ID\fP라는 것을 관리한다.
이 프로세스 그룹의 멤버(자신의 프로세스 그룹 ID가 현재 터미널 프로세스
그룹 ID와 동일한 프로세스들)는 
.SM
.BR SIGINT
와 같이 키보드를 통해 발생시키는 시그널을 받는다.  이러한 프로세스는
.IR 포그라운드
에 놓여 있다고 말한다.
.I 백그라운드
프로세스란 자신의 프로세스 그룹 ID가 터미널의 프로세스 그룹 ID와 다른
프로세스를 말한다;  이 프로세스는 키보드를 통해 발생시키는 시그널에
면역을 가진다.  오로지 포그라운드 프로세스만이 터미널로부터 읽고 터미널에
쓸 수 있다.  터미널로부터 읽거나 쓰려고 시도하는 백그라운드 프로세스는
터미널 드라이버가 보내는
.SM
.B SIGTTIN (SIGTTOU)
시그널을 받는다.  그리고 이를 잡아 처리하지 않으면 프로세스를 일시
중지시킨다.
.PP
.B bash
가 실행 중인 운영체제에서 작업 제어를 지원하면
.B bash
는 여러분으로 하여금 작업 제어 기능을 사용할 수 있도록 해준다.
프로세스 실행 중
.I 일시중지
문자 ( 보통
.BR ^Z ,
Control-Z)를 누르면 프로세스가 멈추고 여러분에게 
.BR bash
프롬프트가 나온다.
.I "지연된 일시중지(delayed suspend)"
문자를 누르면(보통
.BR ^Y ,
Control-Y)프로세스가 터미널로부터 입력을 받으려고 할 때 중지되며
.BR bash
로 제어권이 넘어온다.  그 다음에는 
.B bg
명령을 사용하여 백그라운드에서 실행을 계속하도록 하거나
.B fg
명령을 사용하여 포그라운드에서 실행을 계속하도록 또는
.B kill
명령을 사용하여 죽이는 등 작업의 상태를 제어할 수 있다.
\fB^Z\fP는 즉시 효력을 발휘하며 아직 출력되지 않은 내용과 타이핑을 했으나
입력 처리되지 않은 내용은 버린다.
.PP
쉘에서 어떤 작업을 지시하는 방법은 몇 가지 있다.
.B %
문자는 작업 이름과 관련있다.
작업 번호
.I n
은
.BR %n
으로 표시한다.  또한 작업을 시작할 때 사용했던 이름의 앞 글자나
명령행의 일부 문자열을 사용하여 가리킬 수 있다.
예를 들어,
.B %ce
는 중단된
.B ce
작업을 가리킨다.
job.  접두어가 하나 이상의 작업과 일치할 때에는
.B bash
가 에러를 보고한다.
한편 
.BR %?ce
를 사용하면, 명령행 중간에
.B ce
를 포함하고 있는 작업을 가리킨다.  그 일부 문자열과 일치하는 작업이
여러 개일 때에는
.B bash
가 에러를 보고한다.
.B %%
표시와
.B %+
표시는 쉘에서 포그라운드에 있던 동안 중단된 가장 최신의 작업을
가리키며
.IR "현재 작업(current job)"
이라 부른다.
.I "이전 작업(previous job)"
은
.BR %\-
표시를 통해 가리킬 수 있다.
작업을 가리키는 출력 내용에서 (예를 들어,
.B jobs
명령의 출력 내용) 현재 작업은 항상
.BR + 
로 표시하고,
이전 작업은
.BR \-
로 표시한다.
.PP
간단히 작업 이름을 지칭하기만 해도 작업이 포그라운드로 돌아온다:
.B %1
는 
\fB``fg %1''\fP와 같은 뜻이며,
작업 1 번을 백그라운드에서 포그라운드로 오게 한다.
마찬가지로
.B ``%1 &''
는 작업 1 번을 백그라운드에서 작업 재개를 하도록 하며
\fB``bg %1''\fP
와 같다.
.PP
쉘은 작업이 상태를 바꿀 때마다 그 상황을 안다.
보통의 경우,
.B bash
는 다른 출력 내용을 방해하지 않기 위해 프롬프트를 출력할 때까지 기다렸다가
작업의 상태의 변화를 보고한다.
.B set
내부 명령에
.B -b
옵션을 주었다면,
.B bash
는 변화 내용을 즉시 보고한다.
(앞서 나온
.B "쉘 변수"
섹션의
.B notify
설명을 참고하라.)
.PP
작업이 중단된 상태에서
.B bash
를 종료하려고 하면, 쉘은 경고 메시지를 출력한다.
여러분은
.B jobs
명령을 사용하여 작업의 상태를 조사할 수 있다.  이 명령을 실행하거나
곧바로 다시 종료를 시도하면 경고는 나오지 않으며 중단된 작업은 종료한다.
.SH 시그널(SIGNALS)
\fBbash\fP가 대화형 모드일 때에는 
.SM
.B SIGTERM
는 무시하고
(따라서 \fBkill 0\fP해도 대화형 쉘은 죽지 않는다),
.SM
.B SIGINT
는 잡아서 처리한다.(따라서 \fBwait\fP 내부 명령은 인터럽트 가능하다)
어떤 경우든 \fBbash\fP는
.SM
.BR SIGQUIT
를 무시한다.
작업 제어 중일 때
.B bash
는
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU ,
.SM
.BR SIGTSTP
를 무시한다.
.PP
\fBbash\fP가 시작한 동기화된 작업은 부모로부터 쉘에 의해 상속받은
값으로 시그널을 설정한다.  작업 제어 중이 아닐 때
백그라운드 작업은
(
.BR &
로 시작한 작업 )
.SM
.B SIGINT ,
.SM
.BR SIGQUIT
를 무시한다.
명령 대체의 결과로 실행된 명령은 키보드에 의해 발생하는 작업 제어 시그널인
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU ,
.SM
.BR SIGTSTP
를 무시한다.
.SH "명령 실행(COMMAND EXECUTION)"
명령이 단어로 분리된 후, 그 결과 간단한 명령과 인수 목록이 나오면,
다음 행동이 취해진다.
.PP
명령 이름에 슬래쉬가 포함되어 있지 않으면 쉘을 명령의 위치를 찾는다.
만약 그 이름을 가진 쉘 함수가 존재하면 
.SM
.BR FUNCTIONS
섹션에서 설명한 것처럼 함수가 실행된다.
그런 함수가 없으면 쉘 내부 명령 목록을 검색한다.  만약 일치하는 것이
발견되면 내부 명령이 실행된다.
.PP
쉘 함수 또는 내부 명령 중 어느 것과도 일치하지 않고 슬래쉬를 포함하고
있지 않으면,
.B bash
는
그 이름을 가진 실행 파일이 들어있는 디렉토리를 찾기 위해
.SM
.B PATH
의 각 원소를 검색한다.
검색에 실패하면 쉘은 에러 메시지를 출력하고 0 아닌 종료 상태값을 반환한다.
.PP
검색에 성공하거나 또는 명령 이름에 하나 이상의 슬래쉬가 포함되어 있을
때에는 그 이름을 가진 프로그램을 실행한다.
전달 인수 0 는 그 이름으로 설정되고, 나머지 전달 인수가 있다면 명령에
대한 전달 인수로 설정된다.
.PP
실행 파일 형식이 아니거나 디렉토리가 아니어서 실행이 실패하면
쉘 명령을 포함하고 있는 \fI쉘 스크립트\fP로 간주한다.  쉘 스크립트를
실행하기 위해 서브쉘을 생성한다.  서브쉘 자체로 다시 초기화하기 때문에
부모 쉘이 기억하고 있는 명령 위치를 기억한다는 점을 제외하고,
나머지 사항에 대해서는
스크립트를 처리하기 위해 새로운 쉘이 실행된 것이나 다름없다.
(
.SM
\fB쉘 내부 명령\fP
섹션의
.B hash
참고
)
.PP
만약 프로그램이
.BR #!
로 시작하는 파일이라면,
첫번째 행의 나머지 부분은 그 프로그램에 대한 해석기이다.
쉘은 이 실행 파일 형식을 그 자체로 다루지 못하는 운영체제 상에서
주어진 해석기를 실행한다.  해석기에 대한 전달 인수는 
프로그램의 첫번째 행에서 해석기 이름 다음에 나오는 단일 옵션,
그 다음의 프로그램 이름으로 구성되며 명령 인수가 따라 나오면 그것도
포함한다.
.SH 환경(ENVIRONMENT)
프로그램이 실행될 때 프로그램은
.IR 환경
이라고 부르는 문자열 배열을 받는다.
.IR "이름\fR=\fP값"
의 형식을 갖는 \fI이름\fP\-\fI값\fP의 쌍으로 이루어진 목록이다.
.PP
쉘에서 여러 가지 방법으로 환경을 조작할 수 있는 방법을 제공한다.
실행할 때, 쉘은 자신의 환경 변수를 검색한 후 각 이름에 대하여 매개변수를
생성하고 자식 프로세스에게
.I export
하기 위해 자동으로 표시해 둔다.
.B export
와
.B declare \-x
명령을 사용하여 매개변수와 함수를 환경에 추가하거나 삭제할 수 있다.
환경의 매개변수 값을 변경하면 새로운 값이 예전 값을 치환하여 환경의 일부가
된다.  실행한 명령이 상속한 환경은 쉘의 초기 환경(값을 변경할 수 있음)에서
.B unset
명령으로 제거한 것을 빼고
.B export
와
.B declare \-x
명령을 통해 추가한 것으로 이루어진다.
.PP
.I 간단한 명령
또는 함수에 대한 환경은 
.SM
.BR 매개변수
섹션에서 설명한 것처럼 매개변수 지정문을 앞에 두어 임시로 추가할 수 있다.
이러한 지정문은 그 명령의 환경에 대해서만 유효하다.
.PP
.B \-k
플래그가 설정되어 있으면( 아래의
.B set
내부 명령 참고)
명령 앞에 적은 것만이 아니라
.I 모든
매개변수 지정문이 명령에 대한 환경에 놓이게 된다.
.PP
.B bash
가 외부 명령을 실행할 때
.B _
변수는 명령의 완전한 경로명으로 설정되고 그 명령의 환경에 전달된다.
.SH "종료 상태"
쉘에 있어 종료 상태값 0 인 명령은 성공으로 간주한다.  0 이라는 종료 상태값은
성공을 뜻한다.  0 이 아닌 종료 상태값은 실패를 가리킨다.
심각한 시그널을 받아 명령이 종료하면 \fBbash\fP는 종료 상태값으로
128+\fB시그널 값\fP을 사용한다.
.PP
명령을 찾을 수 없을 때 그 명령을 실행하기 위해 생성한 자식 프로세스는
127 이라는 값을 반환한다. 명령을 찾았으나 실행 파일이 아는 경우에는
126 을 반환한다.
.PP
\fBbash\fP 그 자체는 문법 오류 때문에 0 아닌 값을 반환하는 경우가 아니라면,
실행한 마지막 명령의 종료 상태값을 반환한다.  
뒤에 나오는 \fBexit\fP 내부 명령도 참고하라.
.SH 프롬프트(PROMPTING)
대화형 모드로 실행하면서,
.B bash
는 
명령을 읽을 준비가 되어 있을 때 주 프롬프트인
.SM
.B PS1
를 표시하고 명령을 완성하기 위해 추가 입력이 필요할 때에는
두번째 프롬프트인
.SM
.B PS2
를 표시한다.
.B Bash
는 다음과 같이 해석되는 백슬래쉬\-해석금지된 특수 문자를 이용하여
프롬프트를 정의하여 사용할 수 있도록 해준다:
.RS
.PD 0
.TP
.B \et
현재 시간을 HH:MM:SS 형식으로 표시
.TP
.B \ed
날자를 "요일 월 일" 형식으로 표시 (예, "Tue May 26")
.TP
.B \en
개행문자
.TP
.B \es
쉘의 이름,
.B $0
의 베이스 이름
(마지막 슬래쉬 뒷 부분)
.TP
.B \ew
현재 작업 디렉토리
.TP
.B \eW
현재 작업 디렉토리의 베이스 이름
.TP
.B \eu
현재 사용자의 사용자명
.TP
.B \eh
호스트 이름
.TP
.B \e#
이 명령의 명령 번호
.TP
.B \e!
이 명령의 히스토리 번호
.TP
.B \e$
유효 UID가 0 이면
if the effective UID is 0, a
.BR # ,
그렇지 않으면
.B $
.TP
.B \ennn
팔진수 \fBnnn\fP에 해당하는 문자
.TP
.B \e\e
백슬래쉬
.TP
.B \e[
비출력 문자의 시퀀스를 시작한다. 프롬프트에 터미널 제어 시퀀스를 넣을
때 사용한다.
.TP
.B \e]
비출력 문자의 시퀀스를 마친다.
.PD
.RE
.PP
명령 번호와 히스토리 번호는 일반적으로 다르다:
명령의 히스토리 번호는 히스토리 목록에서의 위치로서 이 목록에는
히스토리 파일로부터 복원된 명령들이 들어있을 수 있는 반면,
( 뒤에 나오는
.SM
.B 히스토리(HISTORY)
참고 ) 명령 번호는 현재의 쉘 세션 동안 실행한 명령 순서에서의 위치이다.
문자열을 해독한 후, 매개변수 확장, 명령 대체, 연산 확장, 단어 분리를
통해 확장한다.
.SH READLINE
.B \-nolineediting
옵션을 주지 않은 한, 대화형 쉘에서 입력을 읽기를 처리해 주는 라이브러리이다.
기본적으로 행 편집 명령은 이맥스의 명령과 비슷하다.
vi 스타일의 행 편집 인터페이스도 제공된다.
.PP
이 섹션에서 키 입력을 표기할 때 이맥스 스타일의 표기 방법을 사용한다.
컨트롤 키는 C\-\fI키\fR로 표기한다.  예를 들어 C\-n은 컨트롤\-N을
뜻한다.  마찬가지로,
.I 메타
키는 M\-\fI키\fR로 표기하며 따라서 M\-x는 메타\-X를 뜻한다.
(
.I 메타
키가 없는 키보드에서 M\-\fIx\fP는 ESC \fIx\fP를 뜻한다.
이스케이프 키를 누른 다음
.I x
키를 누른다.  ESC는 \fI메타 접두어\fP이다.
M\-C\-\fIx\fP 조합은 ESC\-컨트로\-\fIx\fP 또는 이스케이프 키를 누른 후
컨트롤 키를 누른 채
.I x
키를 누르는 것을 뜻한다.)
.PP
기본 키-바인딩은
.FN ~/.inputrc 
파일을 사용하여 변경할 수 있다.
쉘 변수
.SM
.BR INPUTRC
이 설정되어 있으면 그 값을
.IR ~/.inputrc
대신 사용한다.
이 라이브러리를 사용하는 다른 프로그램에서 자신만의 명령과 바인딩을
추가할 수 있다.
.PP
예를 들어
.RS
.PP
M\-Control\-u: universal\-argument
.RE
또는
.RS
C\-Meta\-u: universal\-argument
.RE
를
.FN ~/.inputrc
에 적으면
M\-C\-u이 readline 명령인
.IR universal\-argument
을 실행하게 된다.
.PP
다음의 심볼 문자 이름을 인식한다:
.IR RUBOUT ,
.IR DEL ,
.IR ESC ,
.IR LFD ,
.IR NEWLINE ,
.IR RET ,
.IR RETURN ,
.IR SPC ,
.IR SPACE ,
.IR TAB .
명령 이름에 덧붙여, readline은 키에다 문자열을 결합하여 키를 누르면
문자열이 삽입되도록 해준다.(\fI매크로\fP)
.PP
readline은 초기화 파일에 명령을 넣어 조정하여 사용할 수 있다.
이 파일의 이름은
.SM
.B INPUTRC
변수의 값으로부터 취한다.  변수가 unset 상태이면 기본값은
.IR ~/.inputrc
이다.
readline 라이브러리를 사용하는 프로그램이 시동하면 초기화 파일을 읽고
키 바인딩과 변수를 설정한다.  readline 초기화 파일에서는 몇 가지 기본적인
구조만 사용할 수 있다.  공백 행은 무시한다.
\fB#\fP로 시작하는 행은 주석이다.
\fB$\fP로 시작하는 행은 조건 구조이다. 이외의 행은 키 바인딩 또는
변수 설정을 나타낸다.
.PP
.I ~/.inputrc
파일 안에서 키 바인딩을 제어하는 문법은 간단하다.
명령의 이름 또는 결합되는 매크로와 키 시퀀스의 텍스트만이 필요하다.
이름은 두 가지 중 한 가지 방식을 사용하여 명시할 수 있다:
\fIMeta-\fP 또는 \fIControl-\fP 접두어를 사용하는 심볼 키 이름 또는
키 시퀀스이다.
\fB키이름\fP:\fI함수-이름\fP 또는 \fI매크로\fP 형식을 사용할 때,
.I 키이름
이란 영어로 된 키 이름이다.  예를 들어:
.sp
.RS
Control-u: universal\-argument
.br
Meta-Rubout: backward-kill-word
.br
Control-o: ">&output"
.RE
.LP
위 예에서,
.I C-u
는
.BR universal\-argument
라는 함수에 결합된다.
.I M-DEL
은
.BR backward\-kill\-word
함수에 결합되고,
.I C-o
는 오른쪽에 적은 매크로를 실행하도록 결합된다.(즉, 
.I >&output
라는 텍스트를 행에 추가한다.)
.PP
두번째 형태인,
\fB"키시퀀스"\fP:\fI함수-이름\fP 또는 \fI매크로\fP에서,
.B 키시퀀스
는 전체 키 시퀀스를 더블 쿼우트 안에 넣어 표시할 수 있다는 점에서
.B 키이름
과 다르다.
다음 예에서처럼 일부 GNU 이맥스 스타일의 키 이스케이프를 사용할 수 있다.
.sp
.RS
"\eC-u": universal\-argument
.br
"\eC-x\eC-r": re\-read\-init\-file
.br
"\ee[11~": "Function Key 1"
.RE
.PP
이 예에서,
.I C-u
는
.BR universal\-argument
함수에 결합된다.
.I "C-x C-r"
는
.BR re\-read\-init\-file
함수에 결합되고,
.I "ESC [ 1 1 ~"
는
.BR "Function Key 1"
라는 텍스트를 입력하도록 결합된다.
이스케이프 시퀀스는 다음과 같다:
.RS
.TP
.B \eC\-
컨트롤 접두어
.TP
.B \eM-
메타 접두어
.TP
.B \ee
이스케이프 문자
.TP
.B \e\e
백슬래쉬
.TP
.B \e"
글자 그대로의 "
.TP
.B \e'
글자 그대로의 '
.RE
.PP
매크로 텍스트를 넣을 때에는 매크로 정의라는 것을 지시하기 위해
싱글 또는 더블 쿼우트를 사용해야 한다.  쿼우트하지 않은 텍스트는
함수 이름이라고 간주한다.  백슬래쉬는 " 와 ' 를 포함하여 매크로 텍스트
안의 모든 문자를 쿼우트할 수 있다.
.PP
.B Bash
에서는
.B bind
내부 명령을 사용하여
현재의 readline 키 바인딩을 표시하거나 수정할 수 있다.
.B set
내부 명령에
.B \-o
옵션을 주어 대화형 모드에서 편집 모드를 전환할 수 있다.
(
.SM
.B 쉘 내부 명령
참고 )
.PP
Readline에는 행동 방식을 좀 더 변경할 수 있도록 해주는 변수가 있다.
이 변수는
.I inputrc
파일에 
.RS
.PP
\fBset\fP \fI변수\-이름\fP \fI값\fP
의 형식을 갖는 문장을 통해 설정할 수 있다.
.RE
.PP
특별히 거론하는 경우를 제외하고 readline 변수는
.B On
또는
.BR Off
의 값을 취한다.
변수와 각 기본값은 다음과 같다:
.PP
.PD 0
.TP
.B horizontal\-scroll\-mode (Off)
\fBOn\fP으로 설정하면 readline은 한 줄로 화면에 표시하며 화면 폭보다
긴 입력에 대해서는 자동으로 줄바꿈하지 않고 수평 방향으로 스크롤한다.
.TP
.B editing\-mode (emacs)
readline이 \fIemacs\fP 와 \fIvi\fP와 유사한 키 바인딩 집합 중 어느
것으로 시작할 것인지 제어한다.
.B editing\-mode
모드는
.B emacs
또는
.BR vi
이 가능하다.
.TP
.B mark\-modified\-lines (Off)
\fBOn\fP로 설정하면 히스토리 중 수정된 사항은 그 앞에 애스테리스크
(\fB*\fP)를 넣어 표시한다.
.TP
.B bell\-style (audible)
readline에서 터미널 벨을 울리고자 할 때 어떻게 할 것인지 제어한다.
\fBnone\fP으로 설정하면 소리를 내지 않는다.
\fBvisible\fP로 설정하면 사용 가능한 경우 비주얼 벨을 사용한다.
\fBaudible\fP로 설정하면 터미널의 벨 기능을 시도한다.
.TP
.B comment\-begin (``#'')
.B vi\-comment
명령이 실행될 때 \fBvi\fP 모드에서 삽입되는 문자열
.TP
.B meta\-flag (Off)
\fBOn\fP으로 설정하면 터미널의 지원 여부와 상관없이 8 비트 입력을
가능케 한다.(즉 읽어 들이는 문자의 상위 비트를 자르지 않는다.)
.TP
.B convert\-meta (On)
\fBOn\fP으로 설정하면 8 비트 문자를 8 번째 비트 제거한 ASCII 키 시퀀스 앞에
이스케이프 문자를 넣어 변환한다.(실제로 \fI메타 접두어\fP를 이스케이프로
사용한다.)
.TP
.B output\-meta (Off)
\fBOn\fP으로 설정하면 8 번째 비트를 포함하고 있는 문자열을 표시할 때
메타 접두어를 사용한 이스케이프 시퀀스로 표시하지 않고 그대로 직접 표시한다.
.TP
.B completion\-query\-items (100)
\fBpossible\-completions\fP 명령에 의하여 발생된 가능한 완성 목록의 갯수가
몇 개를 넘으면 사용자에게 물어볼 것인지 결정한다.
0 보다 크거나 같은 정수로 설정한다.  가능한 완성의 갯수가 이 변수의 값보다
크면 사용자에게 전체를 볼 것인지 아닌지 묻는다; 그렇지 않을 때에는 그냥
터미널에 나열한다.
.TP
.B keymap (emacs)
현재 readline 키맵을 설정한다.  가능한 키맵 이름으로는
\fIemacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command\fP,
.IR vi-insert
가 있다.
\fIvi\fP는 \fIvi-command\fP와 같다; \fIemacs\fP는 \fIemacs-standard\fP와 같다.
기본값은
.IR emacs
이다;
.B editing\-mode
의 값이 또한 기본 키맵에 영향을 준다.
.TP
.B show\-all\-if\-ambiguous (Off)
완성 함수의 기본 행동 방식을 변경한다.
.BR on
으로 설정하면 하나 이상의 완성이 가능한 단어에 대하여 소리를 내지 않고
즉시 그 목록을 보여준다.
.TP
.B expand\-tilde (Off)
\fBon\fP으로 설정하면 단어 완성을 시도할 때 틸드 확장을 한다.
.PD
.PP
Readline은 키 바인딩과 변수 설정을 테스트의 결과에 따라 수행하게 해주는
C 전처리기의 조건적 컴파일과 유사한 기능을 구현하고 있다.  3 가지
파서 지시자가 사용된다.
.IP \fB$if\fP
.B $if
구조를 사용하여 편집 모드, 사용하고 있는 터미널, readline을 사용하는
애플리케이션에 따라 바인딩을 다르게 할 수 있다.
테스트 텍스트는 행의 끝까지이다; 테스트 텍스트를 다른 것과 구분하는 문자는 없다.
.RS
.IP \fBmode\fP
\fB$if\fP 지시자의 \fBmode=\fP 형태는 readline이 이맥스 모드인가 vi 모드인가
테스트할 때 사용한다.  예를 들어, \fBset keymap\fP 명령과 함께 사용하여
readline이 이맥스 모드로 시작했을 때에만 \fIemacs-standard\fP의 바인딩과
\fIemacs-ctlx\fP 키맵을 설정하도록 할 수 있다.
.IP \fBterm\fP
\fBterm=\fP 형태는 터미널의 펑션 키에 키 시퀀스 출력을 결합하는 등의
특정 터미널 키 바인딩에서 사용한다.
.B =
의 오른쪽 단어를 터미널의 완전한 이름과 이름 중 첫번째 \fB\-\fP의 앞 부분과
테스트한다.  예를 들어,
.I sun
은
.I sun
과
.IR sun\-cmd
둘 다 일치하게 된다.
.IP \fBapplication\fP
\fBapplication\fP 구조는 애플리케이션별 설정을 포함할 때 사용한다.
readline 라이브러리를 사용하는 각 프로그램은 \fI애플리케이션 이름\fP을
설정하며 초기화 파일에서 이 특정값을 테스트할 수 있다.
특정 프로그램에서 유용한 함수에 키 시퀀스를 결합하는데 사용된다.
예를 들어, 다음 명령은 bash에서 현재 또는 이전 단어를 쿼우트하는 
키 시퀀스를 추가한다:
.RS
.nf
\fB$if\fP Bash
# Quote the current or previous word
"\eC-xq": "\eeb\e"\eef\e""
\fB$endif\fP
.fi
.RE
.RE
.IP \fB$endif\fP
이 명령은 앞에서 본 것처럼
\fB$if\fP 명령을 종결한다.
.IP \fB$else\fP
이 가지에 속한 명령은 \fB$if\fP 지시자의 테스트에 실패했을 때 실행된다.
.PP
Readline 명령에는 수치
.IR 인수
를 줄 수 있는데 일반적으로 반복 횟수를 의미한다.  하지만 종종 인수의
부호가 중요할 때가 있다.  앞 방향으로 동작하는 명령(예, \fBkill\-line\fP)
에 음수 인수를 전달하면 뒷 방향으로 동작한다.  전달한 인수에 따라 명령의
행동 방식이 바뀌는 것에 대해서는 언급한다.
.PP
어떤 명령이 텍스트를 \fI죽인다(kill)\fP라고 할 때, 삭제된 그 텍스트는
나중에 불러 사용할 것을 위해 저장된다.(\fIyanking\fP이라고 부른다)
죽인 텍스트는 \fIkill\-ring\fP이라는 곳에 보관된다.
연속적으로 텍스트를 죽이면 한 단위로 축적되어 한 번에 다시 yank할 수 있다.
텍스트를 죽이지 않는 명령은 kill\-ring에서 텍스트를 서로 분리한다.
.PP
다음은 명령 이름과 기본값으로 결합되어 있는 키 시퀀스 목록이다.
.SS 이동을 위한 명령
.PP
.PD 0
.TP
.B beginning\-of\-line (C\-a)
현재 행의 처음으로 이동
.TP
.B end\-of\-line (C\-e)
현재 행의 끝으로 이동
.TP
.B forward\-char (C\-f)
한 문자 앞으로 이동
.TP
.B backward\-char (C\-b)
한 문자 뒤로 이동
.TP
.B forward\-word (M\-f)
다음 단어의 끝으로 전진 이동.
단어는 알파벳숫자 문자로 구성된다.  (문자와 숫자)
.TP
.B backward\-word (M\-b)
현재 단어 또는 이전 단어의 처음으로 후진 이동.
단어는 알파벳숫자 문자로 구성된다.  (문자와 숫자)
.TP
.B clear\-screen (C\-l)
현재 행을 화면 상단에 두고 화면을 지운다.  인수가 있으면
화면을 지우지 않은 채 현재 행을 갱신한다.
.TP
.B redraw\-current\-line
현재 행을 갱신한다.  기본적으로 결합된 키가 없다.
.PD
.SS 히스토리 처리 명령
.PP
.PD 0
.TP
.B accept\-line (Newline, Return)
커서가 어디에 있든 행을 받아들인다.  빈 행이 아니면 
.SM
.B HISTCONTROL
변수의 상태에 따라 히스토리 목록에 추가한다.  만약 히스토리 행을 수정한
것이라면 히스토리 행을 원래 상태로 복원한다.
.TP
.B previous\-history (C\-p)
히스토리 목록에서 뒤로 이동하여 이전 명령을 가져온다.
.TP
.B next\-history (C\-n)
히스토리 목록에서 앞으로 이동하여 다음 명령을 가져온다.
.TP
.B beginning\-of\-history (M\-<)
히스토리의 첫번째 행으로 이동
.TP
.B end\-of\-history (M\->)
입력 히스토리의 끝으로 이동. 즉, 현재 입력하고 있던 행으로 돌아옴
.TP
.B reverse\-search\-history (C\-r)
현재 행부터 시작하여 히스토리를 올라가면서 후방으로 검색한다.
누적 검색이다.
.TP
.B forward\-search\-history (C\-s)
현재 행부터 시작하여 히스토리를 내려가면서 전방으로 검색한다.
누적 검색이다.
.TP
.B non\-incremental\-reverse\-search\-history (M\-p)
현재 행부터 시작하여 히스토리를 후방으로 검색하되 누적 검색을 하지 않는다.
.TP
.B non\-incremental\-forward\-search\-history (M\-n)
현재 행부터 시작하여 히스토리를 전방으로 검색하되 누적 검색을 하지 않는다.
.TP
.B history\-search\-forward
현재 행의 시작부터 현재 점까지의 문자열을 히스토리에서 전방으로 검색한다.
누적 검색을 하지 않는다.  기본적으로 결합되어 있지 않다.
.TP
.B history\-search\-backward
현재 행의 시작부터 현재 점까지의 문자열을 히스토리에서 후방으로 검색한다.
누적 검색을 하지 않는다.  기본적으로 결합되어 있지 않다.
.TP
.B yank\-nth\-arg (M\-C\-y)
현재 커서 지점에서 이전 명령에 대한 첫번째 인수를 삽입한다.
(보통 이전 행의 두번째 단어에 해당된다.)
인수
.IR n
을 적으면 이전 명령으로부터 \fIn\fP 번째 단어를 삽입한다.(이전 명령의
단어는 0 부터 순서를 매긴다)  음수인 경우 이전 명령의 끝에서 \fIn\fP 번째
단어를 삽입한다.
.TP
.B
yank\-last\-arg (M\-.\^, M\-_\^)
이전 명령의 마지막 인수를 삽입한다.(이전 행의 마지막 단어)
인수를 주면 \fByank-nth-arg\fP과 동일하게 동작한다.
.TP
.B shell\-expand\-line (M\-C\-e)
쉘이 입력을 받는 동안 하는 것처럼 행을 확장한다.  모든 쉘 단어 확장은
물론 앨리어스, 히스토리 확장을 수행한다.
히스토리 확장에 대해서는
뒤에 나오는
.SM
.B 히스토리 확장
을 참고하라.
.TP
.B history\-expand\-line (M\-^)
현재 행에 대하여 히스토리 확장을 수행한다.
히스토리 확장에 대해서는 뒤에 나오는
.SM
.B 히스토리 확장
을 참고하라.
.TP
.B insert\-last\-argument (M\-.\^, M\-_\^)
\fByank\-last\-arg\fP와 동의어
.TP
.B operate-and-get-next (C\-o)
현재 행을 받아들여 실행하고 편집을 위하여 히스토리로부터 현재 행에 대하여
다음 행을 가져온다.  모든 인수는 무시한다.
.PD
.SS 텍스트 변경 명령
.PP
.PD 0
.TP
.B delete\-char (C\-d)
커서 아래 있는 문자를 삭제한다.  행의 시작 부분에 있을 때, 행에 아무런
글자도 없을 때 그리고 마지막 문자를 입력하지 않았을 때
.BR C\-d
는
.SM
.BR EOF
를 반환한다.
.TP
.B backward\-delete\-char (Rubout)
커서 뒤에 있는 문자를 삭제한다.  수치 인수를 주면 kill\-ring에 삭제한
텍스트를 저장한다.
.TP
.B quoted\-insert (C\-q, C\-v)
이 다음부터 타이핑하는 문자를 행에 있는 그대로 추가한다.  예를 들어,
\fBC\-q\fP와 같은 문자를 삽입할 때 사용한다.
.TP
.B tab\-insert (C-v TAB)
탭 문자를 삽입한다.
.TP
.B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
입력한 문자를 삽입한다.
.TP
.B transpose\-chars (C\-t)
입력점에 앞에 있는 문자와 입력점에 놓인 문자를 서로 교환한다.
입력점도 앞으로 전진한다.  입력점이 행의 끝에 있으면 입력점 앞에 있는
두 문자를 치환한다.  음수 인수는 작동하지 않는다.
.TP
.B transpose\-words (M\-t)
커서 뒤에 있는 단어를 커서 앞으로 끌어 놓는다.  커서 또한 이동한다.
.TP
.B upcase\-word (M\-u)
현재(또는 뒤에 나오는) 단어를 대문자화한다.  음수 인수를 주면 앞 단어에
대하여 대문자화를 진행하지만 입력점은 움직이지 않는다.
.TP
.B downcase\-word (M\-l)
현재(또는 뒤에 나오는) 단어를 소문자화한다.  음수 인수를 주면 앞 단어에
대하여 소문자화를 진행하지만 입력점은 움직이지 않는다.
.TP
.B capitalize\-word (M\-c)
현재(또는 뒤에 나오는) 단어의 첫글자를 대문자화한다.  음수 인수를 주면 앞
단어에 대하여 수행하며 입력점은 움직이지 않는다.
.PD
.SS 죽이기와 붙이기(Killing, Yanking)
.PP
.PD 0
.TP
.B kill\-line (C\-k)
현재 커서 위치로부터 행 끝까지 텍스트를 죽인다.
.TP
.B backward\-kill\-line (C\-x C\-Rubout)
현재 커서 위치로부터 행의 앞까지 텍스트를 죽인다.
.TP
.B unix\-line\-discard (C\-u)
현재 입력점으로부터 행의 앞까지 텍스트를 죽인다.
.\" 이 함수와 backward-kill-line과의 실제적인 차이는 없다.
.TP
.B kill\-whole\-line
커서가 어디에 있든 현재 행의 모든 문자를 죽인다.  기본적으로 결합되어 있지
않는다.
.TP
.B kill\-word  (M\-d)
커서 위치로부터 현재 단어의 끝까지 또는 단어 중간인 경우 그 다음 단어의
끝까지 죽인다.  단어 경계는 \fBforward\-word\fP 에서 사용하는 것과 동일하다.
.TP
.B backward\-kill\-word (M\-Rubout)
커서 뒤의 단어를 죽인다.  단어 경계는 \fBforward\-word\fP 에서 사용하는 것과
동일하다.
.TP
.B unix\-word\-rubout (C\-w)
화이트스페이스를 단어 경계로 하여 커서 뒤의 단어를 죽인다.
단어 경계는 backward\-kill\-word에서와 다르다.
.TP
.B delete\-horizontal\-space
입력점 주변의 모든 스페이스와 탭을 삭제한다.  기본적으로 키와 결합되어
있지 않다.
.TP
.B yank (C\-y)
kill ring의 상단에 놓인 것을 커서 위치의 버퍼에 붙인다.
.TP
.B yank\-pop (M\-y)
kill\-ring을 순환시킨 후 상단의 것을 붙인다.  
.B yank
또는
.BR yank\-pop
다음에만 동작한다.
.PD
.SS 수치 인수
.PP
.PD 0
.TP
.B digit\-argument (M\-0, M\-1, ..., M\-\-)
이미 축적 중인 인수에 이 숫자를 더하거나 새로운 인수를 시작한다.
M\-\- 는 음수 인수를 시작한다.
.TP
.B universal\-argument
실행할 때마다 인수 갯수에 4 를 곱한다.  인수 갯수는 처음에 1 이다.  따라서
한 번 실행하면 인수 갯수가 4 가 된다.  기본적으로 키에 결합되어 있지 않다.
.PD
.SS 완성
.PP
.PD 0
.TP
.B complete (TAB)
입력점 앞의 텍스트에 대하여 완성을 시도한다.
.B Bash
는 텍스트를 순서대로 변수(\fB$\fP로 텍스트가 시작하면), 사용자 이름(\fB~\fP로
시작하면), 호스트 이름(\fB@\fP로 시작하면) 또는 명령(앨리어스와 함수 포함)으로
취급하여 완성을 시도한다.  일치하는 것이 없을 때에는 파일 이름 완성을
시도한다.
.TP
.B possible\-completions (M-?)
입력점 앞의 텍스트에 대한 완성 후보 목록을 보여준다.
.TP
.B insert\-completions
\fBpossible\-completions\fP로 만들어 질 수 있는 모든 완성 텍스트를 입력점
앞에 삽입한다.  기본적으로 키와 결합되어 있지 않다.
.TP
.B complete\-filename (M\-/)
입력점 앞의 텍스트에 대하여 파일 이름 완성을 시도한다.
.TP
.B possible\-filename\-completions (C\-x /)
입력점 앞의 텍스트를 파일 이름으로 간주하고 완성 후보 목록을 보여준다.
.TP
.B complete\-username (M\-~)
입력점 앞의 텍스트에 대하여 사용자 이름 완성을 시도한다.
.TP
.B possible\-username\-completions (C\-x ~)
입력점 앞의 텍스트를 사용자 이름으로 간주하고 완성 후보 목록을 보여준다.
.TP
.B complete\-variable (M\-$)
입력점 앞의 텍스트에 대하여 쉘 변수 완성을 시도한다.
.TP
.B possible\-variable\-completions (C\-x $)
입력점 앞의 텍스트를 쉘 변수로 간주하고 완성 후보 목록을 보여준다.
.TP
.B complete\-hostname (M\-@)
입력점 앞의 텍스트에 대하여 호스트 이름 완성을 시도한다.
.TP
.B possible\-hostname\-completions (C\-x @)
입력점 앞의 텍스트를 호스트 이름으로 간주하고 완성 후보 목록을 보여준다.
.TP
.B complete\-command (M\-!)
입력점 앞의 텍스트에 대하여 명령 완성을 시도한다.
명령 완성은 텍스트를 앨리어스, 예약어, 쉘 함수, 내부 명령, 마지막으로
실행 파일 이름 순으로 일치를 시도한다.
.TP
.B possible\-command\-completions (C\-x !)
입력점 앞의 텍스트를 명령 이름으로 간주하고 완성 후보 목로을 보여준다.
.TP
.B dynamic\-complete\-history (M-TAB)
입력접 앞의 텍스트를 히스토리 목록의 행과 비교하여 완성을 시도한다.
.TP
.B complete\-into\-braces (M\-{)
파일 이름 완성을 수행하고 완성 후보 목록을 쉘에서 사용할 수 있도록
중괄호 안에 넣는다.
( 앞서 나온
.B 중괄호 확장
을 참고 )
.PD
.SS 키보드 매크로
.PP
.PD 0
.TP
.B start\-kbd\-macro (C-x (\^)
입력하는 문자를 현재 키보드 매크로에 저장하기 시작한다.
.TP
.B end\-kbd\-macro (C-x )\^)
현재 키보드 매크로에 저장하기를 멈추고 정의 내용을 저장한다.
.TP
.B call\-last\-kbd\-macro (C-x e)
최근에 정의한 키보드 매크로를 다시 실행하여 마치 키보드로 입력한 것처럼
매크로 안의 문자를 보여준다.
.PD
.SS 기타
.PP
.PD 0
.TP
.B re\-read\-init\-file (C\-x C\-r)
여러분의 초기화 파일 내용을 다시 읽어 모든 바인딩과 변수 지정을 현재 환경에
추가한다.
.TP
.B abort (C\-g)
현재 진행 중인 편집 명령을 중지하고 터미널 벨을 울린다.
(
.BR bell\-style
설정에 따라 벨이 울릴 것인지 여부는 달라진다)
.TP
.B do\-uppercase\-version (M\-a, M\-b, ...)
해당하는 대문자와 결합된 명령을 실행한다.
.TP
.B prefix\-meta (ESC)
다음 입력하는 문자를 메타화한다.
.SM
.B ESC
.B f
는
.BR 메타\-f
와 동일하다.
.TP
.B undo (C\-_, C\-x C\-u)
각 행에 대하여 기억된 내용으로 누증 편집 명령 되돌리기를 행한다.
.TP
.B revert\-line (M\-r)
행에 가해진 모든 변화 내용을 취소하고 원래대로 돌려 놓는다.
행의 초기 상태로 돌려 놓기 위해
.B undo
명령을 여러 번 실행한 것과 같다.
.TP
.B tilde\-expand (M\-~)
현재 단어에 대한 틸드 확장을 수행한다.
.TP
.B dump\-functions
readline 출력 스트림에 모든 함수와 키 바인딩을 출력한다.
수치 인수를 주면 \fIinputrc\fP 파일에 넣을 수 있는 형태로 형식화해서
출력해준다.
.TP
.B display\-shell\-version (C\-x C\-v)
현재 실행 중인
.BR bash
의 버전 정보를 보여준다.
.PD
.SH 히스토리(HISTORY)
대화형 모드에서 쉘은 이전에 입력한 명령 목록인 \fI명령 히스토리\fP를
접근할 수 있도록 해준다.
최근
.SM
.B HISTSIZE
갯수의 명령 텍스트는(기본 500) 히스토리 목록에 저장된다.  쉘은 각 명령에
대하여 매개변수 확장과 변수 확장 전에 히스토리 목록에 저장한다.
(
.SM
.B 확장
참고 ) 그러나
.B command_oriented_history
와
.SM
.BR HISTCONTROL
변수의 값에 따라 히스토리 확장을 수행한 후에 저장하기도 한다.
시동할 때, 히스토리는 
.SM
.B HISTFILE
변수가 가리키는 파일로부터 초기화된다.
(기본값 \fI~/.bash_history\fP).
.B HISTFILESIZE
보다 커지지 않도록 필요할 때에는
.SM
.B HISTFILE
파일을 잘라낸다.
내부 명령
.B fc
(
.SM
.B 쉘 내부 명령
참고)을 사용하여 히스토리를 보거나 일부 명령을 편집하여 재실행할 수 있다.
.B history
내부 명령을 사용하여 히스토리 목록을 표시하고 히스토리 파일을 조작할 수 있다.
명령행 편집을 사용할 때 각 모드마다 히스토리 목록을 검색할 수 있는 명령이
있다.  대화형 쉘을 종료하면 최근
.SM
.B HISTSIZE
행만큼이 히스토리 목록으로부터
.SM
.BR HISTFILE
로 복사된다.
.SM
.B HISTFILE
을 unset하거나 히스토리 파일에 쓸 수 없을 때는 히스토리를 저장하지 않는다.
.SH "히스토리 확장(HISTORY EXPANSION)"
.PP
쉘에서는
.BR csh
의 히스토리 확장과 유사한 히스토리 확장 기능을 지원한다.  이 섹션에서는
사용 가능한 기능의 문법을 설명한다.  대화형 쉘에서는 기본 동작하며
.B \+H
option to the
.B set
내부 명령에
.B \+H
옵션을 주어 해제할 수 있다.
(
.SM
.B 쉘 내부 명령
참고) 비대화형 모드 쉘에서는 히스토리 확장을 수행하지 않는다.
.PP
히스토리 확장은 완전한 행이 읽히고 쉘이 단어로 분리하기 전에 즉시 수행된다.
두 부분에서 일어난다.  우선 이전 히스토리로부터 어떤 행을 가져가 치환에
사용할 것인지 결정한다.  두번째는 현재 행에 포함시키기 위해 그 행의 일부분을
선택한다.  이전 히스토리로부터 선택된 행을 \fI이벤트(event)\fP라 하며
행동이 취해 질 그 행의 일부분을 \fI단어(words)\fP라고 한다.
행은 입력을 읽어 들일 때와 같은 방식으로 단어로 분리되며 따라서 
몇 가지 \fI메타문자\fP에 의해 구분된 단어가 쿼우트로 둘러 싸이면는 하나의
단어로 취급한다.
오로지 백슬래쉬(\^\fB\e\fP\^)와 싱글 쿼우트만이 히스토리 이스케이프 문자를
(기본값 \^\fB!\fP\^) 쿼우트할 수 있다.
.PP
히스토리 확장 메커니즘에서 사용하는 다양한 문자를 제어할 수 있다.
(
.BR "쉘 변수"
섹션에서
.B histchars
설명 참고 )
.SS 이벤트 지시자(Event Designators)
.PP
이벤트 지시자는 히스토리 목록의 명령행 항목에 대한 참조이다.
.PP
.PD 0
.TP
.B !
그 뒤에
.BR 공백 ,
개행문자, = 또는 (
가 나오는 경우를 제외하고 히스토리 치환을 시작하도록 한다.
.TP
.B !!
이전 명령을 가리킨다. `!\-1'와 동의어이다.
.TP
.B !\fIn\fR
.IR n 
번 명령행을 가리킨다.
.
.TP
.B !\-\fIn\fR
현재 명령행에서
.IR n 
를 뺀 행을 가리킨다.
.TP
.B !\fI문자열\fR
.IR 문자열
로 시작하는 가장 최근 명령을 가리킨다.
.TP
.B !?\fI문자열\fR\fB[?]\fR
.IR 문자열
을 포함하는 가장 최근 명령을 가리킨다.
.TP
.B \d\s+2^\s-2\u\fI문자열1\fP\d\s+2^\s-2\u\fI문자열2\fP\d\s+2^\s-2\u
빠른 치환. 지난 번 명령에 대하여
.I 문자열1
을
.IR 문자열2
로 바꾸어 실행한다.
``!!:s/\fI문자열1\fP/\fI문자열2\fP/''와 같다.
(\fB변경자(Modifiers)\fP 참고).
.TP
.B !#
지금까지 입력한 전체 명령행.
.PD
.SS 단어 지시자
.PP
.B :
는 단어 지시자로부터 이벤트 명시를 분리한다.
단어 지시자가
.BR ^ ,
.BR $ ,
.BR * ,
.BR %
로 시작할 때에는 생략할 수 있다.
단어는 행의 처음부터 시작하여 세며 첫번째 단어는 0(숫자 영) 으로 나타낸다.
.PP
.PD 0
.TP
.B 0 (숫자 영)
0 번째 단어. 쉘에 있어 명령 단어에 해당한다.
.TP
.I n
\fIn\fR번째 단어.
.TP
.B ^
첫번째 인수 즉 단어 1 이다.
.TP
.B $
마지막 인수.
.TP
.B %
가장 최근의
`?\fI문자열\fR?' 검색과 일치하는 단어
.TP
.I x\fB\-\fPy
단어의 범위; `\-\fIy\fR' 는 `0\-\fIy\fR'와 같이 줄여 쓴다.
.TP
.B *
0 번째를 제외한 모든 단어.  `\fI1\-$\fP'와 동의어이다
이벤트에 단어 하나만 있을 때에도
.B *
를 사용하는 것은 에러가 아니다;  이 경우 빈 문자열이 반환된다.
.TP
.B x*
\fIx\-$\fP를 줄여 쓴 것이다.
.TP
.B x\-
\fBx*\fP와 같이
\fIx\-$\fP를 줄여 쓴 것이지만 마지막 단어를 제외한다.
.PD
.SS 변경자(Modifiers)
.PP
선택적인 단어 지시자 뒤에 앞에 `:'를 붙여 다음과 같은 변경자를 추가할 수 있다.
.PP
.PD 0
.PP
.TP
.B h
머리 부분만 남기도 뒷부분 경로명 부분을 제거한다.
.TP
.B r
베이스 이름만 남기고 \fI.xxx\fP 형태의 뒷부분 꼬리말을 제거한다.
.TP
.B e
꼬리말을 제외하고 모두 제거한다.
.TP
.B t
꼬리 부분은 남기고 앞에 나오는 모든 경로명 부분을 제거한다.
.TP
.B p
새로운 명령을 출력하지만 실행하지는 않는다.
.TP
.B q
치환된 단어를 쿼우트하여 더 이상 치환이 일어나지 않도록 해석금지시킨다.
.TP
.B x
.BR q
과 함께 사용하여 치환된 단어를 쿼우트한다.  그러나
.B 공백
과 개행문자에서 단어를 분리한다.
.TP
.B s/\fI예전것\fP/\fI새것\fP/
이벤트 행에서 처음 나오는
.I 예전것
을
.I 새것
으로 교체한다. / 대신 어떤 분리자도 사용 가능하다.
마지막 분리자가 이벤트 행의 마지막 단어일 때는 생략 가능하다.
.I 예전것
과
.I 새것
안에서 단일 백슬래쉬를 사용하여 분리자를 쿼우트할 수 있다.
.IR 새것
안에 & 이 있으면 그 문자는
.IR 예전것
으로 치환된다.
단일 백슬래쉬를 사용하여 & 를 쿼우트할 수 있다.
.TP
.B &
이전 치환을 반복한다.
.TP
.B g
변화 내용을 전체 이벤트 행에 적용하도록 한다.
`\fB:s\fP' (예, `\fB:gs/\fI예전것\fP/\fI새것/\fR') 또는
`\fB:&\fP'와 사용한다.  If used with
`\fB:s\fP'와 사용하면 / 대신 어떤 분리자든 사용할 수 있으며 마지막 분리자가
이벤트 행의 마지막 문자일 때는 생략할 수 있다.
.PD
.SH "산술 평가(ARITHMETIC EVALUATION)"
쉘은 특정 상황에서 산술 표현식을 계산할 수 있도록 해준다.
( \fBlet\fP 내부 명령과 \fB연산 확장\fP 참고 )
평가는 오버플로우 점검 없이 long 형 정수로 이루어진다. 0 으로 나누는 것은
잡아내어 에러로 표시한다.  다음 연산자 목록은 같은 우선 순위를 갖는 것끼리
모았다.  나열한 순위는 내림 차순이다.
.PP
.PD 0
.TP
.B \- +
단일 마이너스와 플러스
.TP
.B ! ~
논리적 그리고 비트수준 부정
.TP
.B * / %
곱하기, 나누기, 나머지 연산
.TP
.B + \-
더하기, 빼기
.TP
.B << >>
왼쪽, 오른쪽 비트 쉬프트
.TP
.B <= >= < >
비교
.TP
.B == !=
같다, 같지 않다
.TP
.B &
비트수준 AND
.TP
.B ^
비트수준 배타적(exclusive) OR
.TP
.B |
비트수준 OR
.TP
.B &&
논리적 AND
.TP
.B ||
논리적 OR
.TP
.B = *= /= %= += \-= <<= >>= &= ^= |=
지정
.PD
.PP
피연산자로 쉘 변수를 사용할 수 있다; 표현식을 평가하기 전에 매개변수 확장이
수행된다.  매개변수의 갑은 표현식 안에서 long 형 정수로 강제 전환한다. 표현식에
사용하기 위해 쉘 변수의 정수 속성을 켤 필요는 없다.
.PP
0으로 시작하는 상수는 8 진수로 해석한다.
\fI0x\fP 또는 \fI0X\fP로 시작하면 16 진수를 뜻한다.  그 외의 경우에 대해서는
[\fIbase#\fP]n 형태로 숫자를 받아들인다.  여기서
\fIbase\fP는 진법을 나타내는 2 부터 36 사이의 10진수이며 \fIn\fP는 그 진법
안에서의 숫자이다.
\fIbase\fP를 생략하면 10 진법을 사용한다.
.PP
연산자는 우선 순위에 의거하여 평가해 나간다. 괄호 안의 서브 표현식은
먼저 평가하며 위에서 말한 우선 순위를 무시하도록 한다.
.SH "쉘 내부 명령(SHELL BUILTIN COMMANDS)"
.\" start of bash_builtins
.zZ
.PD 0
.TP
\fB:\fP [\fI인수들\fP]
.PD
아무런 효과도 없다; 
.I 인수들
을 확장하고 명시된 리다이렉션을 행하는 것을 제외하고 아무 일도 하지 않는다.
종료 상태값 0 을 반환한다.
.TP
.PD 0
\fB .\| \fP \fI파일명\fP [\fI인수들\fP]
.TP
\fBsource\fP \fI파일명\fP [\fI인수들\fP]
.PD
.I 파일명
으로부터 명령을 읽어
현재 쉘 환경 안에서 실행한다.
.IR 파일명
에서 읽어 수행한 마지막 명령의 종료 상태값을 반환한다.
.I 파일명
에 슬래쉬가 없으면 
.SM
.B PATH
변수에 들어있는 경로명을 사용하여 
.IR 파일명
을 검색한다.
.SM
.B PATH
변수에서 찾는 파일이 실행 파일일 필요는 없다.
.SM
.BR PATH
에서 파일을 찾을 수 없으면 현재 디렉토리를 찾는다.
\fI인수들\fP을 적으면 \fI파일\fP을 실행할 때 위치 매개변수로 사용한다.
그렇지 않으면 위치 매개변수는 변하지 않는다.  스크립트 내에서 종료한
마지막 명령의 상태값을 반환하고(아무 명령도 실행되지 않았으면 0)
.I 파일명
을 찾을 수 없으면 거짓을 반환한다.
.TP
\fBalias\fP [\fI이름\fP[=\fI값\fP] ...]
아무런 인수 없이
\fBAlias\fP를 실행하면 표준 출력에 \fI이름\fP=\fI값\fP의 형식으로 앨리어스
목록을 출력해준다.  인수를 제공하면
각각의 \fI이름\fP에 대하여 \fI값\fP을 앨리어스로 정의한다.
\fI값\fP 뒤에 스페이스를 두면 앨리어스 확장 시 그 다음 단어에 대해서도
앨리어스 확장이 가능한지 점검하도록 할 수 있다.
인수 목록에서 \fI값\fP을 주지 않은 \fI이름\fP에 대해서는 앨리어스의 이름과
값을 출력한다.  주어진 \fI이름\fP에 대한 앨리어스가 정의되어 있지 않은 경우가
아니라면 참값을 반환한다.
.TP
\fBbg\fP [\fI작업명세\fP]
.BR &
를 붙여 실행한 것처럼
\fI작업명세\fP가 가리키는 작업을 백그라운드로 보낸다.
\fI작업명세\fP가 없으면 \fI현재 작업\fP에 해당하는 작업이 사용된다.
.B bg
.I 작업명세
는 작업 제어가 불가능한 상태에서 실행하거나, 작업 제어는 가능하지만
\fI작업명세\fP를 찾을 수 없거나 작업 제어 없이 시작한 경우를 제외하고
0 을 반환한다.
.TP
.PD 0
\fBbind\fP [\fB\-m\fP \fI키맵\fP] [\fB\-lvd\fP] [\fB-q\fP \fI이름\fP]
.TP
\fBbind\fP [\fB\-m\fP \fI키맵\fP] \fB-f\fP \fI파일명\fP
.TP
\fBbind\fP [\fB\-m\fP \fI키맵\fP] \fI키시퀀스\fP:\fI함수이름\fP
.PD
.B readline
의 현재 키, 함수 바인딩을 표시하거나
.B readline
함수나 매크로에 키 시퀀스를 결합한다.
바인딩 문법은 
.IR .inputrc
의 문법과 같지만 각 바인딩을 개별적인 인수로 전달해야 한다;
예를 들어, '"\eC-x\eC-r": re\-read\-init\-file'.
옵션을 적는 경우에는 다음과 같은 의미를 가진다:
.RS
.PD 0
.TP
.B \-m \fI키맵\fP
뒤이어 나오는 바인딩에 의해 영향을 받는 키맵으로
.I 키맵
을 사용한다.
가능하
.I 키맵
이름으로는
\fIemacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command\fP,
그리고
.IR vi-insert
이 있다.
\fIvi\fP는 \fIvi-command\fP와 같다; \fIemacs\fP는
\fIemacs-standard\fP와 같다.
.TP
.B \-l
모든 \fBreadline\fP 함수의 이름을 나열한다.
.TP
.B \-v
현재 함수 이름과 바인딩을 나열한다.
.TP
.B \-d
다시 읽을 수 있는 형태로 함수 이름과 바인딩을 덤프한다.
.TP
.B \-f \fI파일명\fP
\fIfilename\fP으로부터 키 바인딩을 읽는다.
.TP
.B \-q \fI함수\fP
\fI함수\fP를 실행시키는 키에 대하여 알아본다.
.PD
.PP
알 수 없는 옵션이 주어졌거나 에러가 발생한 경우가 아닐 때에는 0 이 반환된다.
.RE
.TP
\fBbreak\fP [\fIn\fP]
.BR for ,
.BR while ,
.B until
루프 안에서 탈출한다.
\fIn\fP을 명시하면 \fIn\fP 레벨을 탈출한다.
.I n
은 \(>= 1 여야 한다.
.I n
이 둘러 싸고 있는 루프의 갯수보다 크면 모든 루프를 탈출한다.
.B break
이 실행될 때 루프를 실행 중이 아닌 경우를 제외하고 0 을 반환한다.
.TP
\fBbuiltin\fP \fI쉘\-내부명령\fP [\fI인수들\fP]
명시한 쉘 내부 명령에 
.IR 인수들
을 주어 실행하고 종료 상태값을 반환한다.
쉘 내부 명령과 같은 이름의 함수를 정의하고 그 함수 안에서 내부 명령의
기능을 활용하고자 할 때 유용하다.
보통 \fBcd\fP 내부 명령을 이런 식으로 재정의하곤 한다.
.I 쉘\-내부명령
이 쉘 내부 명령이 아닐 때 거짓을 반환한다.
.TP
\fBcd\fP [\fI디렉토리\fP]
현재 디렉토리를 \fI디렉토리\fP로 변경한다.
.SM
.B HOME
변수 값이 기본
.IR 디렉토리
값이다.
.SM
.B CDPATH
변수는
.IR 디렉토리
를 포함하는 디렉토리에 대한 검색 경로를 정의한다.
서로 다른 디렉토리는 콜론(:)으로 구분한다.
.SM
.B CDPATH
에 널 디렉토리 이름을 넣으면 현재 디렉토리 즉 ``\fB.\fP''와 같다.
.I 디렉토리
가 슬래쉬(/)로 시작하면
.SM
.B CDPATH
는 사용되지 않는다.
전달인수로
.B \-
를 사용하면
.SM
.BR $OLDPWD
와 같다.
성공적으로 디렉토리를 변경하면 참, 그렇지 않으면 거짓을 반환한다.
.TP
\fBcommand\fP [\fB-pVv\fP] \fI명령\fP [\fI인수\fP ...]
보통의 쉘 함수 찾아보기를 하지 않고
.I 명령
을
.I 인수
와 함께 실행한다.  내부 명령 또는
.SM
.B PATH
에서 찾을 수 있는 명령만을 실행한다.
are executed.  If the
.B \-p
옵션을 주면
.B PATH
의 기본값을 사용하여
.I 명령
에 대한 검색을 하므로 표준 유틸리티를 찾을 수 있도록 보장해 준다.
.B \-V
또는
.B \-v
옵션을 주면
.I 명령
에 대한 설명을 출력한다.
.B \-v
옵션은
.I 명령
을 호출할 때 사용할 명령 또는 경로명을 가리키는 간단한 단어를 출력한다;
.B \-V
옵션은 좀 더 자세한 설명을 출력한다.
.B \-\-
를 전달 인수로 적으면 나머지 인수에 대한 옵션 점검을 하지 않는다.
.B \-V
또는
.B \-v
옵션을 주었을 때 종료 상태값은
.I 명령
이 발견되면 0, 그렇지 않으면 1 이 된다. 두 옵션 모두 없고 에러가 발생하거나
.I 명령
을 찾을 수 없으면 종료 상태값은 127 이 된다.  그렇지 않을 때 
.B command
내부 명령의 종료 상태값은 
.IR 명령
의 종료 상태값이다.
.TP
\fBcontinue\fP [\fIn\fP]
둘러 싸고 있는
.BR for ,
.BR while ,
.B until
루프의 다음 순차 작업을 재개한다.
.I n
을 명시하면, \fIn\fP 번째 루프를 재개한다.
.I n
은 \(>= 1 여야 한다.
.I n
이 둘러 싸고 있는 루프 갯수보다 크면 가장 바깥쪽의 루프(`최상위 레벨' 루프)를
재개한다.
.B continue
명령을 실행할 때 쉘이 루프를 실행하고 있지 않은 경우가 아니라면 반환값은
0 이다.
.TP
.PD 0
\fBdeclare\fP [\fB\-frxi\fP] [\fI이름\fP[=\fI값\fP]]
.TP
\fBtypeset\fP [\fB\-frxi\fP] [\fI이름\fP[=\fI값\fP]]
.PD
변수를 선언하거나 변수에 속성을 부여한다.  아무런 \fI이름\fP도 주어지지
않았을 때에는 변수의 값을 표시한다.  옵션을 사용하여 특정 속성의 변수에
대해서만 출력하도록 제한할 수 있다.
.RS
.PD 0
.TP
.B \-f
함수 이름만 사용
.TP
.B \-r
\fI이름\fP을 읽기 전용으로 만든다.  그 뒤에는 지정문을 사용하여 값을
지정할 수 없다.
.TP
.B \-x
\fI이름\fP을 그 뒤에 나오는 명령에게 환경을 통해 export하도록 한다.
.TP
.B \-i
변수를 정수처럼 취급한다;  변수에 값을 지정하면 산술 평가(
.SM
.B "산술 평가"
참고 )를 수행한다.
.PD
.PP
이 옵션을 끄려면 `\-' 대신 `+'를 사용한다.  함수 안에서 사용하면
.B local
명령처럼 \fI이름\fP을 지역적으로 만든다.  잘못된 옵션을 만났다든지,
"-f foo=bar"를 사용하여 함수를 정의하려고 시도했다든지,
\fI이름\fP이 적접한 쉘 변수 이름이 아니라든지, 읽기 전용 변수의 읽기 전용
상태를 해제하려 한다든지, 또는 -f 를 가지고 존재하지 않은 함수를
표시하려 한 경우가 아니라면 반환값은 0 이다.
.RE
.TP
.B dirs [\fB-l\fP] [\fB+/\-n\fP]
현재까지 기억하고 있는 디렉토리 목록을 표시한다.  디렉토리를 목록에
추가할 때에는
.B pushd
명령을 사용한다;
.B popd
명령은 목록으로부터 최근 디렉토리를 꺼내고 그 디렉토리로 이동하도록 한다.
.RS
.PD 0
.TP
.B +n
옵션은 아무 옵션 없이
.B dirs
를 실행했을 때 보이는 목록의 왼쪽부터 세어 \fIn\fP번째 항목을 보여준다.
0 부터 시작한다.
.TP
.B \-n
옵션은 아무 옵션 없이
.B dirs
를 실행했을 때 보이는 목록의 오른쪽부터 세어 \fIn\fP번째 항목을 보여준다.
0 부터 시작한다.
.TP
.B \-l
긴 목록을 만들어 보여준다; 기본 목록 나열 형식에서는 홈 디렉토리를 나타낼
때 틸드를 사용한다.
.PD
.PP
틀린 옵션을 주거나 \fIn\fP 이 디렉토리 스택 범위를 넘어서는 경우가
아니라면 반환값은 0 이 된다.
.RE
.TP
\fBecho\fP [\fB\-neE\fP] [\fI인수\fP ...]
스페이스로 구분되어 있는 \fI인수\fP들을 출력한다.  반환값은 항상
0 이다.  \fB\-n\fP을 명시하면 마지막의 개행문자를 출력하지 않는다.
\fB\-e\fP 옵션을 주면 백슬래쉬 이스케이프 문자를 해석할 수 있도록 해준다.
.B \-E
옵션은 시스템에서 기본적으로 이스케이프 문자를 해석하는 상황이라 할 지라도
이스케이프 문자를 해석하지 않도록 지시한다.
.RS
.PD 0
.TP
.B \ea
경고 (벨)
.TP
.B \eb
백스페이스
.TP
.B \ec
마지막 개행문자를 생략함
.TP
.B \ef
폼 피드
.TP
.B \en
개행문자
.TP
.B \er
캐리지 리턴
.TP
.B \et
수평 탭
.TP
.B \ev
수직 탭
.TP
.B \e\e
백슬래쉬
.TP
.B \ennn
ASCII 코드가 \fInnn\fP (8진수)인 문자
.PD
.RE
.TP
\fBenable\fP [\fB\-n\fP] [\fB\-all\fP] [\fI이름\fP ...]
쉘 내부 명령을 켜거나 큰다.  이 기능을 사용하면 쉘 내부 명령과 같은
이름을 갖는 디스크 명령에 대하여 완전한 경로명을 적지 않고도 실행할 수
있다.
\fB\-n\fP을 사용하면 각 \fI이름\fP의 사용을 끈다;  그렇지 않으면
\fI이름\fP의 사용을 켠다.  예를 들어, 쉘 내부 명령 버전 대신
.B PATH
에서 찾을 수 있는
.B test
바이너리를 사용하려면
``enable -n test'' 라고 실행한다.
인수가 없으면 사용 가능한 모든 쉘 내부 명령 목록을 출력한다.
\fB\-n\fP만 주면 사용 불능 상태의 내부 명령 목록을 출력한다.
\fB\-all\fP만 주면 모두 내부 명령에 대하여 가능, 불가능 여부를 표시하여
출력해준다.
.B enable
명령은
.BR \-all
대신
.B \-a
도 받아들인다.
.I 이름
이 쉘 내부 명령이 아닌 경우를 제외하고 반환값은 0 이다.
.TP
\fBeval\fP [\fI인수\fP ...]
모든 \fI인수\fP를 읽어 하나의 명령으로 결합한다.
그 다음 이 명령을 읽어 쉘에서 실행하고 종료 상태값을
.B eval
명령의 반환값으로 돌려준다.
.IR 인수
가 하나도 없거나 널 인수이면
.B eval
은 참을 반환한다.
.TP
\fBexec\fP [[\fB\-\fP] \fI명령\fP [\fI인수\fP]]
.I 명령
을 명시하면 그 명령으로 쉘 프로세스를 교체한다.
새로운 프로세스는 만들어지지 않는다.
.I 인수
는 \fI명령\fP의 인수가 된다.
첫번째 인수가
.BR \-
이면 쉘은 
.IR 명령
에 전달하는 0 번째 인수에 대쉬를 넣는다.  이 과정은 로그인이 하는 일과
같다.  어떤 이유에서든 파일을 실행할 수 없으면 쉘 변수
\fBno_exit_on_failed_exec\fP가 존재하여 거짓을 반환하는 경우를 제외하고
비대화형 쉘은 종료한다.  파일을 실행할 수 없을 때 대화형 쉘은 거짓을
반환한다.
.I 명령
을 명시하지 않으면 현재 쉘에서 리다이렉션만 효력을 발휘하고 반환값은
0 이 된다.
.TP
\fBexit\fP [\fIn\fP]
상태값 \fIn\fP을 가지고 쉘을 종료한다.
.I n
을 생략하면 실행한 마지막 명령의 종료 상태값을 갖는다.
쉘을 종료하기 전에
.SM
.B EXIT
에 대한 트랩(trap) 루틴이 실행된다.
.TP
.PD 0
\fBexport\fP [\fB\-nf\fP\^] [\fI이름\fP[=\fI단어\fP]] ...
.TP
.B export \-p
.PD
나열한
.I 이름
을 그 다음에 나오는 명령들의 환경에 자동적으로 export되도록 기억해 둔다.
.B \-f
옵션을 주면
.I 이름
은 함수를 가리킨다.
아무런
.I 이름
도 적지 않거나 또는
.B \-p
옵션을 주면 쉘에서 export되는 모든 이름 목록을 출력한다.
.B \-n
옵션은 주어진 이름의 변수로부터 export 속성을 제거하도록 한다.
.B \-\-
인수를 주면 그 나머지 인수에 대한 옵션 점검을 하지 않도록 한다.
잘못된 옵션을 만나거나 \fI이름\fP이 적법한 쉘 변수 이름이 아니거나
또는 함수가 아닌
.B 이름
에 대하여 
.B \-f
옵션을 준 경우가 아니라면
.B export
는 종료 상태값 0 을 반환한다.
.TP
.PD 0
\fBfc\fP [\fB\-e\fP \fI편집기이름\fP] [\fB\-nlr\fP] [\fI처음\fP] [\fI마지막\fP]
.TP
\fBfc\fP \fB\-s\fP [\fI패턴\fP=\fI치환텍스트\fP] [\fI명령\fP]
.PD
명령을 수정한다.  첫번째 형식에서, 명령의 범위는
.I 처음
부터
.I 마지막
범위에 있는 명령을 히스토리 목록에서 선택한다.
.I 처음
과
.I 마지막
은 문자열(그 문자열로 시작하는 최근 명령을 찾고자 할 때) 또는 숫자
(히스토리 목록의 인덱스로 사용하며 음수일 때에는 현재 명령 번호로부터
떨어진 만큼을 뜻한다)로 명시할 수 있다.
.I 마지막
을 명시하지 않으면 현재 명령으로 설정되고(따라서
.B fc \-l \-10
은 최근 10 개의 명령을 출력하게 된다) 그렇지 않으면
.I 처음
까지 출력한다.
If
.I 처음
을 명시하지 않으면 편집을 위해 이전 명령으로 설정하고 표시를 위해
\-16 을 설정한다.
.sp 1
.B \-n
플래그를 적으면 나열할 때 명령 번호가 나타나지 않게 한다.
.B \-r
플래그는 명령의 표시 순서를 반대로 한다.
.B \-l
플래그가 있으면 명령을 표준 출력에 나열한다.  그렇지 않을 때에는
.I 편집기이름
이 가리키는 편집기에서 이 명령들을 포함하는 파일을 열면서 시작한다.
.I 편집기이름
이 없으면
.SM
.B FCEDIT
변수의 값을 사용하며
.SM
.B FCEDIT
가 설정되어 있지 않을 때에는
.SM
.B EDITOR
값을 사용한다.
둘 다 설정되어 있지 않으면
.FN vi
를 사용한다.  편집을 마친 후에는 편집한 명령들이 화면에 표시되고
실행된다.
.sp 1
두번째 형태에서, \fI명령\fP은 \fI패턴\fP이 \fI치환텍스트\fP로 교체된 후에
다시 실행된다.  유용한 앨리어스로는 ``r=fc \-s''가 있다.  앨리어스 적용 후
``r cc'' 라고 치면 ``cc''로 시작하는 최근 명령을 실행하고 ``r''이라고
치면 마지막 명령을 다시 실행하게 된다.
.sp 1
첫번째 형태를 사용하면 잘못된 옵션이 있거나
.I 처음
또는
.I 마지막
이 히스토리 행 범위를 벗어나지만 않으면 반환값 0 을 갖는다.
.B \-e
옵션을 주면 마지막 실행 명령의 값이 반환값이 되거나 명령의 임시 파일에서
오류가 발생하는 경우 실패 값을 가진다.  두번째 형태를 사용하면
.I 명령
이 유효한 히스토리 행을 가리키지 못하여 
.B fc
가 실패를 반환하는 경우가 아니라면 재실행한 명령의 반환값을 반환값으로
사용한다.
.TP
\fBfg\fP [\fI작업스펙\fP]
.I 작업스펙
이 가리키는 바를 포그라운드에 놓고 현재 작업이 되도록 한다.
.I 작업스펙
이 존재하지 않으면 쉘에서 \fI현재 작업\fP이라고 부르는 것을 사용한다.
반환값은 포그라운드에 놓인 명령의 반환값이거나 작업 제어 불가능 상태에서
실행된 경우에는 실패이다.
그리고 작업 제어 가능한 상태에서도
.I 작업스펙
이 유효한 작업을 가리키지 않거나 
.I 작업스펙
이 작업 제어 없이 실행된 작업을 가리킬 때에도 실패이다.
.TP
\fBgetopts\fP \fI옵션문자열\fP \fI이름\fP [\fI인수\fP]
.B getopts
는 위치 매개변수를 파싱하기 위해 사용하는 쉘 프로시져이다.
.I 옵션문자열
은 인식하고자 하는 옵션 문자를 포함한다; 문자 뒤에 콜론이 오면 옵션 다음에
화이트스페이스로 분리된 인수가 온다는 뜻이다.
매번 실행될 때마다,
.B getopts
는 다음 옵션을
쉘 변수
.IR 이름
에 넣는다.
.I 이름
이 존재하지 않을 때에는 초기화한다.  그리고 처리할 다음 인수의 인덱스는
.SM
.BR OPTIND
변수에 넣는다.
.SM
.B OPTIND
는 쉘 또는 쉘 스크립트가 실행될 때마다 1 로 초기화된다.
옵션에서 인수를 필요로 할 때에는
.B getopts
에서 그 인수를
.SM
.BR OPTARG
변수에 넣는다.
쉘이 자동으로
.SM
.B OPTIND
변수를 재설정하지는 않는다;같은 쉘 실행 상태에서 새로운 매개변수 집합을
사용하려면 
.B getopts
를 부를 때마다 수동으로 재설정해 주어야 한다.
.sp 1
.B getopts
는 두 가지 방식으로 오류를 보고할 수 있다.  
.I 옵션문자열
의 첫번째 문자가 콜론이면
.I 조용한
오류 보고가 사용된다.  정상 동작 상태에서는 잘못된 옵션 또는 누락된 인수의
경우 증상을 설명하는 메시지가 출력된다.
.SM
.B OPTERR
변수를 0 으로 설정하면 
.I 옵션문자열
의 첫번째 문자가 콜론이 아니라 하더라도 오류 메시지를 출력하지 않는다.
.sp 1
잘못된 옵션을 만나면,
.B getopts
는
.I 이름
에 ? 를 넣고 조용하게 보고하는 상태가 아닌 경우,
오류 메시지를 출력하고
.SM
.BR OPTARG
를 unset 한다.
.B getopts
이 조용한 모드에 있는 경우 찾아낸 옵션 문자를
.SM
.B OPTARG
에 넣고 증상 설명 메시지를 출력하지 않는다.
.sp 1
필요한 인수를 찾을 수 없으며
.B getopts
가 조용한 모드에 있지 않을 때에는 물음표를
(\^\fB?\fP\^)
.IR 이름
에 넣고
.B OPTARG
를 unset 하며 증상 설명 메시지를 출력한다.
.B getopts
가 조용한 모드에 있으면 콜론을 (\^\fB:\fP\^)
.I 이름
에 넣고
.SM
.B OPTARG
을 찾아낸 옵션 문자로 설정한다.
.sp 1
.B getopts
는 보통 위치 매개변수를 파싱하지만 
.IR 인수
부분에 더 많은 인수를 주면
.B getopts
는 대신 그 인수를 파싱한다.
.B getopts
는 명시한 것이든 명시하지 않은 것이든 옵션을 찾으면 참을 반환한다.
옵션의 끝이거나 에러가 발생하면 거짓을 반환한다.
.TP
\fBhash\fP [\fB\-r\fP] [\fI이름\fP]
각
.IR 이름
에 대하여,
그 이름이 가리키는 명령의 완전한 경로명을 결정하여 기억해 둔다.
.B \-r
옵션을 주면 기억해 둔 위치를 모두 잊도록 지시한다.
아무런 인수도 적지 않으면 기억해 둔 명령에 대한 정보를 출력한다.
.B \-\-
라는 인수를 주면 그 뒤에 있는 인수에 점검을 하지 않도록 지시한다.
.I 이름
이 없거나 잘못된 옵션이 주어진 경우가 아닌 경우에는 참을 반환한다.
.TP
\fBhelp\fP [\fI패턴\fP]
내부명령에 대한 도움말을 출력한다.
.I 패턴
을 적으면,
.B help 는
.IR 패턴 과
일치하는 모든 명령에 대하여 자세한 도움말을 준다;
패턴을 적지 않으면 모든 내부명령 목록을 출력한다.
.IR 패턴 과
일치하는 명령이 없는 경우를 제외하고 반환값은 0 이다.
.
.TP
.PD 0
\fBhistory\fP [\fIn\fP]
.TP
\fBhistory\fP \fB\-rwan\fP [\fIfilename\fP]
.\".TP
.\"\fBhistory\fP \fB\-s\fP \fIargs\fP
.PD
옵션이 없으면, 행 번호와 함께 명령 히스토리 목록을 표시한다.
.B *
표시가 있는 행은 수정한 적이 있다는 뜻이다.
.I n
인수를 주면 최근
.I n
행만을 표시한다.  옵션이 아닌 인수를 적으면, 히스토리 파일 이름으로
간주한다;없으면
.SM
.B HISTFILE
변수의 값을 사용한다.  옵션이 있는 경우 다음과 같은 뜻을 갖는다:
.RS
.PD 0
.TP
.B \-a
히스토리 파일에 ``새로운'' 히스토리 행(현재 \fBbash\fP 세션의 시작부터
입력한 히스토리 행)을 추가한다.
.TP
.B \-n
히스토리 파일로부터 현재 히스토리 목록으로 아직 읽어들이지 않는 히스토리
행을 읽어들인다.  현재 \fBbash\fP 세션 시작부터 히스토리 파일에 추가한
행을 말한다.
.TP
.B \-r
히스토리 파일의 내용을 읽어 현재 히스토리로 사용한다.
.TP
.B \-w
현재 히스토리를 히스토리 파일의 기존 내용에 덮어 쓴다.
.\".TP
.\".B \-s
.\"perform history
.\"substitution on the following \fIargs\fP and display
.\"the result on the standard output.
.PD
.PP
옵션을 잘못 적거나 히스토리 파일을 읽거나 쓰는 도중 오류가 발생한 경우를
제외하고 반환값은 0 이다.
.RE
.TP
.PD 0
\fBjobs\fP [\fB\-lnp\fP] [ \fI작업스펙\fP ... ]
.TP
\fBjobs\fP \fB\-x\fP \fI명령\fP [ \fI인수\fP ... ]
.PD
첫번째 형태는 활동 중인 작업을 나열한다.
.B \-l
옵션을 더하면 일반적인 정보에 프로세스 ID까지 더하여 나열하도록 한다;
.B \-p
옵션은 작업의 프로세스 그룹 리더의 프로세스 ID만 나열하도록 한다.
.B \-n
옵션은 지난 번 통보 이후 상태 변화를 일으킨 작업만 표시하도록 한다.
.I 작업스펙
을 적으면, 작업스펙에 맞는 작업에 대한 정보만으로 출력을 제한한다.
잘못된 옵션을 적거나 
잘못된
.I 작업스펙
을 적은 경우가 아니라면 반환값은 0 이다.
.sp 1
.B \-x
옵션을 붙이면,
.B jobs
명령은 
.I 명령
또는
.I 인수
안 에서
.I 작업스펙
을 발견할 때마다 해당 프로세스 그룹 ID로 치환하고
.I 명령
에 
.IR 인수
를 주어 실행하고 그 종료 상태값을 반환한다.
.TP
.PD 0
\fBkill\fP [\fB-s 시그널스펙\fP | \fB\-시그널스펙\fP] [\fIpid\fP | \fI작업스펙\fP] ...
.TP
\fBkill\fP \fB\-l\fP [\fI시그널번호\fP]
.PD
.I pid
또는
.IR 작업스펙 이
가리키는 프로세스에게
.I 시그널스펙
이 가리키는 시그널을 보낸다.
.I 시그널스펙
은 
.SM
.B SIGKILL
과 같은 시그널 이름 또는 시그널 번호이다.
.I 시그널스펙
이 시그널 이름인 경우, 대소문자는 구별하지 않으며
.SM
.B SIG
라는 접두어를 써도 되고 쓰지 않아도 된다.
.I 시그널스펙
이 없으면,
.SM
.B SIGTERM
이라고 가정한다.
.B \-l
인수를 적으면 시그널 이름을 나열해 준다.
.B \-l
이 있을 때에는 어떤 인수가 있으면, 특정 시그널의 이름을 나열하고
반환값은 0 이다.
.B \-\-
인수를 주면 그 후 나머지 인수에 대한 옵션 점검을 하지 않도록 강제한다.
.B kill
최소한 한 개의 시그널을 성공적으로 전송했으면 참을 반환한다.
오류가 발생하거나 잘못된 옵션을 만나면 거짓을 반환한다.
.TP
\fBlet\fP \fI인수\fP [\fI인수\fP ...]
각각의
.I 인수
는 계산한 수치 표현식이다.(
.SM
.BR "산술 평가"
참고
).
마지막
.I 인수
를 평가하여 그 결과가 0 이면,
.B let
은 1 을 반환한다;  나머지 경우에는 0 을 반환한다.
.TP
\fBlocal\fP [\fI이름\fP[=\fI값\fP] ...]
각 인수에 대하여 
.IR 이름
이라는 지역 변수를 만들고
.IR 값
을 할당한다.
.B local
을 함수 안에서 사용하면, 
.I 이름
변수의 가시 범위(scope)를 그 함수와 자식 함수로 제한한다.
피연산자가 없으면,
.B local
은 지역변수 목록을 표준 출력으로 출력한다.
.B local
를 함수 안에서 사용하지 않는 것은 오류이다.
.B local
을 함수 외부에서 사용했거나 잘못된
.I 이름
을 적은 경우가 아니라면 반환 상태값은 0 이다.
.TP
.B logout
로그인 쉘을 마친다.
.TP
\fBpopd\fP [\fB+/\-n\fP]
디렉토리 스택에서 항목을 제거한다.  인수가 없으면 스택의 최상위 디렉토리를
제거하고 그 새로운 상위 디렉토리로
.B cd
한다.
.RS
.PD 0
.TP
.B +n
.BR dirs
명령 결과 보이는 목록의 왼쪽부터 세기 시작하여 \fIn\fP번째 항목을 제거한다.
0 부터 센다.
예를 들어,
``popd +0''는 첫번째 디렉토리를,
``popd +1''는 두번째 디렉토리를 제거한다.
.TP
.B \-n
.BR dirs
명령 결과 보이는 목록의 오른쪽부터 세기 시작하여 \fIn\fP번째 항목을 제거한다.
0 부터 센다.
예를 들어, 
``popd -0''는 맨 마지막 디렉토리를,
``popd -1''는 맨 마지막 바로 전 디렉토리를 제거한다.
.PD
.PP
.B popd
명령이 성공적이면,
.B dirs
명령도 실행하며 반환 상태값은 0 이다.
.B popd
는 잘못된 옵션을 적거나, 디렉토리 스택이 비어 있거나, 존재하지 않는
디렉토리 스택 항목을 명시하거나 디렉토리 이동이 실패할 경우 거짓을 반환한다.
.RE
.TP
.PD 0
\fBpushd\fP [\fI디렉토리\fP]
.TP
\fBpushd\fP \fB+/\-n\fP
.PD
디렉토리를 디렉토리 스택의 맨 위에 추가하거나,
스택을 회전시켜 스택의 최 상위 항목을 현재 작업 디렉토리로 만든다.
인수가 없으면, 최상위 두 디렉토리를 교환한다.  디렉토리 스택이 비어 있지
않으면 0을 반환한다.
.RS
.PD 0
.TP
.B +n
\fIn\fP번째 디렉토리(
.BR dirs
명령이 보여주는 목록의 맨 왼쪽부터 센다)
이 맨 위에 놓이도록 스택을 회전시킨다.
)
.TP
.B \-n
\fIn\fP번째 디렉토리(오른쪽부터 센다)가 맨 위에 놓이도록
스택을 회전시킨다.
.TP
.B 디렉토리
.I 디렉토리
를 디렉토리 스택 맨 위에 추가하여 새로운 작업 디렉토리가 되도록 한다.
.PD
.PP
.B pushd
명령이 성공적이면,
.B dirs
명령도 수행한다.
첫번째 형식을 사용하면,
.B pushd
는
.I 디렉토리
로 cd 하는 것을 실패하지 않는 한, 0 을 반환한다.
두번째 형식을 사용하면,
.B pushd
는 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을
선택하거나, 지정한 새 현재 디렉토리로 이동하는데 실패한 경우가 아니면
0을 반환한다.
.RE
.TP
\fBpwd\fP
현재 디레토리의 절대 경로명을 출력한다.
.B set
내부명령의
.B \-P
옵션이 설정되어 있으면 경로명에 심볼릭 링크를 포함하지 않는다.
(
.B 쉘 변수
섹션에서
.B nolinks
에 대한 설명을 참고하라.)
above).
현재 디렉토리의 경로명을 읽는 도중 오류가 발생하지 않았다면 결과 반환값은
0이다.
.TP
\fBread\fP [\fB\-r\fP] [\fI이름\fP ...]
표준 입력으로부터 한 줄을 읽어들여 그 첫번째 단어를 
첫번째
.IR 이름
에 할당하고 두번째 단어를 두번째
.IR 이름
에 할당하고 나머지 남은 단어들을 마지막
.IR 이름
에 할당한다.
.SM
.B IFS
에 있는 단어만을 단어 구분자로 인식한다.
아무런
.I 이름
도 적지 않으면 읽어들인 행을 
.SM
.BR REPLY
변수에 할당한다.
파일 끝 문자를 만난 경우를 제외하고 반환값은 0 이다.
.B \-r
옵션을 주면 백슬래쉬-개행 문자 쌍을 무시하지 않고 백슬래쉬를 행의 일부로
인식한다.
.TP
.PD 0
\fBreadonly\fP [\fB\-f\fP] [\fI이름\fP ...]
.TP
\fBreadonly -p\fP
.PD
주어진 \fI이름\fP들을 읽기 전용으로 표기하고 다음에 나올 대입문에 의해
\fI이름\fP들의 값이 바뀌지 않도록 해 준다.
.B \-f
옵션을 더하면,
\fI이름\fP에 해당하는 함수를 읽기 전용으로 표기한다.
아무런 인수도 없거나
.B \-p
옵션을 주어져 있는 경우에는, 모든 읽기 전용 변수 목록을 출력한다.
.B \-\-
인수는 나머지 인수에 대한 점검을 하지 않도록 지시한다.
잘못된 옵션이 있거나 \fI이름\fP들 중 하나라도 적접한 쉘 변수 이름이
아닌 경우 또는
.B \-f
다음에 나온
.I 이름
이 함수가 아닌 경우를 제외하고는 반환 상태값이 0 이다.
.TP
\fBreturn\fP [\fIn\fP]
함수를 상태 반환값
.IR n
을 갖고 종료하도록 한다.
.I n
을 생략하면 함수 몸체 안에서 실행한 마지막 명령의 반환 상태값을 사용한다.
함수 밖에서 사용했지만 
.B .
(\fBsource\fP) 명령으로 실행한 스크립트에서 사용하면,
쉘은 그 스크립트 실행을 멈추고
.I n
또는 스크립트에서 실행한 마지막 명령의 종료 상태값을 스크립트의 종료 상태값으로
반환한다.
함수 밖에서 사용했으며 \fB.\fP\로 실행한 스크립트가 아니라면
반환 상태값은 거짓이 된다.
.TP
\fBset\fP [\fB\-\-abefhkmnptuvxldCHP\fP] [\fB-o\fP \fI옵션\fP] [\fI인수\fP ...]
.RS
.PD 0
.TP 8
.B \-a
뒤이어 나올 명령의 환경으로 export하기 위해 수정 또는 생성할 변수를 자동으로
표기한다.
.TP 8
.B \-b
종료한 백그라운드 작업의 상태를 다음 번 주 프롬프트 전에 보여 주는 것이
아니라 즉시 보여 주도록 한다.
(
.B 쉘 변수
섹션에서
.B notify
참고)
.TP 8
.B \-e
\fI간단한-명령\fP
(
.SM
.B 쉘 문법
참고)이 0 아닌 상태값을 갖고 종료하면 즉시 종료한다.
만약 실패한 명령이
.I until
또는
.I while
루프의 일부,
.I if
문의 일부,
.B &&
의 일부,
or
.B \(bv\|\(bv
목록의 일부이거나 또는 명령의 반환값이
.BR !
으로 반전되면 종료하지 않는다.
.TP 8
.B \-f
경로명 확장을 하지 않는다.
.TP 8 
.B \-h
함수를 정의할 때 함수 명령을 찾아 기억해 둔다.
함수를 실행할 때 함수 명령을 정상적으로 찾아 본다.
.TP 8
.B \-k
명령 이름 앞에 적은 것 뿐 아니라, 모든 키워드 인수를 명령의 환경에
둔다.
.TP 8
.B \-m
모니터(감시) 모드.  작업 제어를 사용한다.  지원하는 시스템에서 실행하는
대화형 쉘에 대해서는 이 플래그가 자동으로 켜진다.
(
.SM
.B 작업 제어
참고).
백그라운드 작업은 별도의 프로세스 그룹 안에서 실행되며
실행을 완료하면 종료 상태값을 포함하는 행을 출력한다.
.TP 8
.B \-n
명령을 읽지만 실행하지는 않는다.  쉘 스크립트 문법 오류를 점검할 때
사용할 수 있다.  대화형 쉘에서는 무시한다.
.TP 8
.B \-o \fI옵션-이름\fP
\fI옵션-이름\fP은 다음 중 한 가지이다:
.RS
.TP 8
.B allexport
.BR \-a
와 같다.
.TP 8
.B braceexpand
쉘이 중괄호 확장을 행한다.
(
앞서 나온
.B 중괄호 확장
참고) 선택하지 않아도 기본값이다.
.TP 8
.B emacs
이맥스 스타일의 명령행 편집 인터페이스를 사용한다.
쉘을 시작할 때
.B \-nolineediting
옵션을 붙이지 않은 한, 쉘이 대화형 모드일 때의 기본값이다.
.TP 8
.B errexit
.BR \-e 와
같다.
.TP 8
.B histexpand
.BR \-H 와
같다.
.TP 8
.B ignoreeof
마치 쉘 명령 `IGNOREEOF=10'을 실행한 것과 같은 효과를 발휘한다.
(앞서 나온
.B 쉘 변수
참고).
.TP 8
.B interactive\-comments
어떤 단어를
.B #
로 시작하면 그 단어와 그 뒤의 모든 문자를 대화형 쉘에서 무시하도록 한다.
(앞서 나온
.SM
.B 주석
참고).
.TP 8
.B monitor
.BR \-m 와
같다.
.TP 8
.B noclobber
.BR \-C 와
같다.
.TP 8
.B noexec
.BR \-n 와
같다.
.TP 8
.B noglob
.BR \-f 와
같다.
.TP 8
.B nohash
.BR \-d 와
같다.
.TP 8
.B notify
.BR \-b 와
같다.
.TP 8
.B nounset
.BR \-u 와
같다.
.TP 8
.B physical
.BR \-P 와
같다.
.TP 8
.B posix
POSIX 1003.2 표준과 기본적으로 다른 bash의 행동방식을 POSIX 표준을
따르도록 만든다.
.TP 8
.B privileged
.BR \-p 와
같다.
.TP 8
.B verbose
.BR \-v 와
같다.
.TP 8
.B vi
vi 스타일의 명령행 편집 인터페이스를 사용한다.
.TP 8
.B xtrace
.BR \-x 와
같다.
.PP
\fI옵션-이름\fP을 적지 않으면 현재 옵션값을 출력한다.
.RE
.TP 8
.B \-p
.I privileged
모드를 켠다.
이 모드에서는
.B $ENV
파일을 처리하지 않으며, 쉘 함수를 환경으로부터 상속하지 않는다.
유효 사용자 (그룹) ID와 실제 사용자 (그룹) ID가 일치하지 않으면 시동할 때
자동으로 작동한다.  이 옵션을 끄면 유효 사용자, 그룹 ID를 실제 사용자,
그룹 ID로 설정한다.
.TP 8
.B \-t
명령 하나를 읽어 실행한 후 종료한다.
.TP 8
.B \-u
매개변수 확장 시 설정되어 있지 않은 변수를 오류로 간주한다.
미설정 변수에 대한 확장을 시도하면, 쉘은 에러 메시지를 출력하고
대화형 모드가 아니면 0 아닌 상태를 갖고 종료한다.
.TP 8
.B \-v
쉘에서 행 입력을 받을 때마다 그 입력행을 출력한다.
.TP 8
.B \-x
각각의
.IR 간단한-명령
을 확장한 후,
.B bash
.SM
.BR PS4 ,
의 확장값을 표시하고 명령과 확장된 인수를 표시한다.
.TP 8
.B \-l
\fBfor\fP \fI이름\fP [in \fB단어\fP] 명령의 \fI이름\fP 바인딩을
저장하고 복원한다.
(앞서 나온
.SM
.B 쉘 문법
참고).
.TP 8
.B \-d
실행하기 위해 참조하는 명령 해쉬를 사용하지 않는다.
보통 명령을 해쉬 테이블에 기억해 두고 일단 발견하면 다시는 참조할
필요 없다.
.TP 8
.B \-C
쉘 명령 `noclobber='을 실행한 것과 같은 효력을 발휘한다.
(앞서 나온
.B 쉘 변수
참고).
.TP 8
.B \-H
.B !
스타일의 히스토리 치환을 사용한다.
쉘이 대화형 모드이면 기본으로 켜지는 플래그이다.
.TP 8
.B \-P
설정하면,
현재 디렉토리를 변경하는
.B cd
와 같은 명령 실행 중 심볼릭 링크를 따르지 않는다.
대신 물리적인 디렉토리를 사용한다.
.TP 8
.B \-\-
이 플래그 뒤에 아무런 인수도 나오지 않으면 위치 매개변수를 unset한다.
만약 나오면, 
.BR \- 
로 시작하는 것이 있다 할 지라도 위치 매개변수를 \fI인수\fP로 설정한다.
.TP 8
.B \-
옵션의 끝을 나타내며, 그 뒤에 나오는 모든 \fI인수\fP들을 위치 매개변수로
설정한다.
.B \-x
와
.B \-v
옵션이 꺼진다.
만약 아무런 \fI인수\fP도 없다면, 위치 매개변수는 그대로이다.
.PD
.PP
다른 식으로 언급하지 않는 한, 이 플래그는 기본적으로 꺼져 있다.
\- 대신 + 를 사용하면 플래그를 끈다.
쉘을 실행할 때 옵션으로 적을 수 있다.
현재 플래그 상태는
.BR $\- 
를 보면 알 수 있다.
옵션 인수를 처리한 후, 나머지
\fIn\fP 개의 \fI인수\fP는 위 매개변수의 값으로 간주하고
차례대로
.BR $1 ,
.BR $2 ,
.B ...
.BR $\fIn\fP
에 할당한다.
아무런 옵션도 없고 \fI인수\fP도 없으면 모든 쉘 변수를 출력한다.
잘못된 옵션이 없는 한, 반환 상태값은 항상 참이다.
.RE
.TP
\fBshift\fP [\fIn\fP]
\fIn\fP+1 부터의 위치 매개변수 이름을
.B $1
.B ....
로 변경한다.
\fB$#\fP부터 \fB$#\fP\-\fIn\fP+1까지의 매개변수는 unset된다.
.I n
이 0 이면, 매개변수의 변화는 없다.
.I n 
이 주어지지 않으면 1 로 간주한다.
.I n
은 \fB$#\fP보다 작거나 같은 음수 아닌 숫자여야 한다.
.I n
이 \fB$#\fP보다 크면, 위치 매개변수의 변화는 없다.
.I n
이 
.B $#
보다 크거나 0 보다 작으면 반환 상태값은 0 보다 크다;
그렇지 않으면 0 이다.
.TP
\fBsuspend\fP [\fB\-f\fP]
.SM
.B SIGCONT
시그널을 받을 때까지 쉘의 실행을 정지시킨다.
.B \-f
옵션은 로그인 쉘이라 할 지라도  불평 메시지를 출력하지 않도록 한다;
어찌 되었든 일시 정지한다.
쉘이 로그인 쉘이면서도
.B \-f
이 없거나 또는 작업 제어 기능이 작동 중인 상태가 아니면 반환 상태값은
0 이 된다.
.TP
.PD 0
\fBtest\fP \fI표현식\fP
.TP
\fB[\fP \fI표현식\fP \fB]\fP
조건
.IR 표현식
을 평가하여 0 (참) 또는 1 (거짓)을 상태값으로 반환한다.
표현식은 일항 또는 이항 표현식일 수 있다.
일항 표현식은 주로 파일의 상태를 점검할 때 사용한다.
문자열 연산자와 수치 비교 연산자도 있다.
각 연산자와 피연산자는 개별적인 인수 형태를 띠어야 한다.
\fI파일\fP이 /dev/fd/\fIn\fP의 형태일 때에는,
파일 기술자 \fIn\fP를 점검한다.
.RS
.PD 0
.TP
.B \-b \fI파일\fP
\fI파일\fP이 존재하고 블럭 특수 파일이면 참.
.TP
.B \-c \fI파일\fP
\fI파일\fP이 존재하고 문자 특수 파일이면 참.
.TP
.B \-d \fI파일\fP
\fI파일\fP이 존재하고 디렉토리이면 참.
.TP
.B \-e \fI파일\fP
\fI파일\fP이 존재하면 참.
.TP
.B \-f \fI파일\fP
\fI파일\fP이 존재하고 일반 파일이면 참.
.TP
.B \-g \fI파일\fP
\fI파일\fP이 존재하고 set-group-id이면 참.
.TP
.B \-k \fI파일\fP
\fI파일\fP에 ``스틱키(sticky)'' 비트가 설정되어 있으면 참.
.TP
.B \-L \fIf파일\fP
\fI파일\fP이 존재하고 심볼릭 링크이면 참.
.TP
.B \-p \fI파일\fP
\fI파일\fP이 존재하고 명명된(named) 파이프이면 참.
.TP
.B \-r \fI파일\fP
\fI파일\fP이 존재하고 읽을 수 있으면 참.
.TP
.B \-s \fI파일\fP
\fI파일\fP이 존재하고 그 크기가 0 보다 크면 참.
.TP
.B \-S \fI파일\fP
\fI파일\fP이 존재하고 소켓이면 참.
.TP
.B \-t \fIfd\fP
.I fd
(파일 기술자)가 열린 상태이고 터미널이면 참.
.TP
.B \-u \fI파일\fP
\fI파일\fP이 존재하고 set-user-id 비트가 설정되어 있으면 참.
.TP
.B \-w \fI파일\fP
\fI파일\fP이 존재하고 쓸 수 있으면 참.
.TP
.B \-x \fI파일\fP
\fI파일\fP이 존재하고 실행 가능하면 참.
.TP
.B \-O \fI파일\fP
\fI파일\fP이 존재하고 유효(effective) 사용자 ID의 소유이면 참.
.TP
.B \-G \fI파일\fP
\fI파일\fP이 존재하고 유효 그룹 ID의 소유이면 참.
.TP
\fI파일1\fP \-\fBnt\fP \fI파일2\fP
\fI파일1\fP이 (수정 일시에 의거하여) \fI파일2\fP보다 새로운 파일이면 참.
.TP
\fI파일1\fP \-\fBot\fP \fI파일2\fP
\fI파일1\fP이 \fI파일2\fP보다 오래 된 파일이면 참.
.TP
\fI파일1\fP \fB\-ef\fP \fI파일2\fP
\fI파일1\fP과 \fI파일2\fP가 같은 장치이며 아이노드 번호가 같으면 참.
.TP
.B \-z \fI문자열\fP
\fI문자열\fP의 길이가 0이면 참.
.TP
.B \-n \fI문자열\fP
.TP
\fI문자열\fP
.I 문자열
의 길이가 0이 아니면 참.
.TP
\fI문자열1\fP \fB=\fP \fI문자열2\fP
두 문자열이 같으면 참.
.TP
\fI문자열1\fP \fB!=\fP \fI문자열2\fP
두 문자열이 같지 않으면 참.
.TP
.B ! \fI표현식\fP
.I 표현식
이 거짓이면 참.
.TP
\fI표현식1\fP \-\fBa\fP \fI표현식2\fP
.I 표현식1
과
.I 표현식2
둘 다 참이면 참.
.TP
\fI표현식1\fP \-\fBo\fP \fI표현식2\fP
.I 표현식1
또는
.I 표현식2
둘 중 하나가 참이면 참.
.TP
.I 인수1 \fB연산자\fP 인수2
.SM
.B 연산자
는
.BR \-eq ,
.BR \-ne ,
.BR \-lt ,
.BR \-le ,
.BR \-gt ,
또는
.BR \-ge
중 하나이다.
위와 같은 수치 이항 연산자는 각각 \fI인수1\fP이 \fI인수2\fP와 
같거나, 같지 않거나, 작거나, 작거나 같거나, 크거나, 크거나 같을 때에 참이다.
.I 인수1
과
.I 인수2
는 양의 정수, 음의 정수 또는 
\fB\-l\fP \fI문자열\fP과 같이
.IR 문자열
의 길이로 평가되는 특별한 표현식이 될 수 있다.
.PD
.RE
.TP
.B times
쉘과 쉘로부터 실행한 프로세스들에 대하여 사용자 영역에서의 소모 시간,
시스템 영역에서의 소모 시간을 출력한다.  반환값은 0 이다.
.TP
\fBtrap\fP [\fB\-l\fP] [\fI인수\fP] [\fI시그널스펙\fP]
쉘이
.IR 시그널스펙
이 가리키고 있는 시그널을 받으면
.I 인수
로 주어진 명령을 읽어 실행하도록 한다.
.I 인수
가 없거나
.BR \-
이면,
제시한 모든 시그널에 대하여 원래의 값으로 돌아간다.
(즉 쉘을 시작했을 때의 값)
.I 인수
가 널 문자열이면
쉘과 쉘이 실행한 명령이 그 시그널을 무시해 버린다.
.I 시그널스펙
은 <\fIsignal.h\fP>에 정의되어 있으면 시그널 이름이거나,
시그널 번호이다.
.I 시그널스펙
이
.SM
.B EXIT
(0) 이면
.I 인수
로 주어진 명령을 쉘 종료 시에 실행한다.
아무런 인수도 없으면,
.B trap
은 각 시그널 번호와 연관된 명령 목록을 출력한다.
.B \-l
옵션을 주면 시그널 이름과 해당하는 번호 목록을 출력한다.
.B \-\-
인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다.
쉘을 시작할 때 무시한 시그널에 대해서는 가로채거나 재설정할 수 없다.
가로 챈 시그널은 자식 프로세스가 새롭게 생성될 때 원래의 값으로 재설정된다.
가로채기 이름 또는 번호가 유효하지 않으면 거짓이고 그렇지 않으면 
.B trap
은 참을 반환한다.
.TP
\fBtype\fP [\fB\-all\fP] [\fB\-type\fP | \fB\-path\fP] \fI이름\fP [\fI이름\fP ...]
옵션없이 사용하면,
.I 이름
이 명령 이름으로 사용하였을 때 어떻게 해석할 것인지 알려 준다.
.B \-type
플래그를 사용하면,
.B type
은
.I 이름
이 각각 앨리어스, 쉘의 예약된 단어, 함수, 내부함수, 또는 디스크 파일일 때,
.IR alias ,
.IR keyword ,
.IR function ,
.IR builtin ,
그리고
.I file 
중 하나를 출력한다.
이름을 찾을 수 없으면 아무 것도 출력하지 않고 반환값은 거짓이 된다.
.B \-path
플래그를 사용하면,
.B type
은
.I 이름
이 명령 이름으로 사용되었을 때 실행될 디스크 파일 이름을 반환하거나,
.B \-type
이 
.IR file 
을 반환하지 않을 때에는 아무 것도 반환하지 않는다.
명령이 해쉬된 상태이면,
.B \-path
는
.BR PATH
상에서 처음으로 나오는 파일이 아니라 해쉬 값을 반환할 것이다.
.B \-all
플래그를 사용하면,
.B type
은
.IR 이름
이라는 이름을 포함하는 실행 파일이 포함된 모든 장소를 포함한다.
.B \-path
플래그를 함께 사용하지 않을 때에만, 앨리어스와 함수를 포함한다.
.BR \-all
을 사용할 때에는 해쉬 명령 테이블을 참조하지 않는다.
.B type
은
.BR \-all ,
.BR \-type ,
과
.BR \-path
대신 각각
.BR \-a ,
.BR \-t ,
과
.B \-p
를 받아들인다.
.B \-\-
인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다.
.B type
은 인수를 발견했을 때에만 참을 반환하고 발견하지 못했을 때에는 거짓을
반환한다.
.TP
\fBulimit\fP [\fB\-SHacdfmstpnuv\fP [\fI제한\fP]]
.B Ulimit
은 제한 기능을 지원하는 시스템 상에서 쉘과 쉘이 실행한 프로세스에 대하여
사용 자우너을 제한할 수 있도록 해 준다.
.I 제한
값은 각 자원에 대한 단위 값이거나
.BR unlimited
라는 값을 가질 수 있다.
\fBH\fP와
\fBS\fP 옵션은 주어진 자원에 대한 하드(hard) 또는 소프트(soft) 설정을 명시한다.
하드 제한은 일단 설정되면 더 이상 늘릴 수 없다;
한편 소프트 제한은 하드 제한 값까지 늘릴 수도 있다.
\fBH\fP 와 \fBS\fP 중 아무 것도 명시되어 있지 않으면 소프트 제한이라고
간주한다.
.I 제한
을 생략하면 \fBH\fP 옵션이 없는 한, 자원의 현재 소프트 제한 값을 출력한다.
여러 개의 자원을 명시했다면 값 앞에 제한 이름과 단위를 출력해 준다.
기타 다른 옵션은 다음과 같이 해석한다:
.RS
.PD 0
.TP
.B \-a
모든 현재 제한 사항을 보고한다.
.TP
.B \-c
코어 파일의 최대 크기
.TP
.B \-d
프로세스의 데이터 세그먼트의 최대 크기
.TP
.B \-f
쉘이 만들 수 있는 파일의 최대 크기
.TP
.B \-m
상주 설정(resident size) 최대 크기
.TP
.B \-s
최대 스택 크기
.TP
.B \-t
초 단위의 최대 CPU 시간
.TP
.B \-p
512 바이트 블럭 단위로 파이프의 크기(설정 가능하지 않을 수 있음)
.TP
.B \-n
열 수 있는 파일 기술자의 최대 크기
(대부분의 시스템에서는 설정을 허용하지 않고 오로지 출력만 한다.)
.TP
.B \-u
단일 사용자에게 허용하는 프로세스 최대 갯수
.TP
.B \-v
쉘에 허용하는 가상 메모리의 최대량
.PD
.PP
.B \-\-
인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 금지한다.
.I 제한
이 주어지면, 명시한 자원에 대한 새로운 값이 된다.(
.B \-a
옵션은 표시할 때만 사용한다.)
아무런 옵션도 없으면
.B \-f
로 간주한다.
값은 초 단위의
.BR \-t ,
512 바이트의 블럭 단위인
.BR \-p ,
그리고 단위가 없는
.B \-n
과
.BR \-u
를 제외하고,
1024 바이트 단위로 생각한다.
잘못된 옵션이 있거나, \fI제한\fP 값에 \fBunlimited\fP 이외의 수치 아닌
인수를 적거나 또는 새로운 제한을 설정하는데 오류가 발생한 경우를 제외하고
반환 상태값은 0 이다.
.RE
.TP
\fBumask\fP [\fB\-S\fP] [\fI모드\fP]
사용자 파일 생성 매스크를
.IR 모드
로 설정한다.
.I 모드
가 숫자로 시작하면 8 진수로 해석한다.  그렇지 않으면
.IR chmod (1)
와 비슷한 심볼릭 매스크로 해석한다.
.I 모드
를 생략하거나,
.B \-S
옵션을 적으면,
현재의 매스크 값을 출력한다.
.B \-S
옵션은 매스크 값을 심볼릭 형태로 출력하도록 한다;
기본 출력 형태는 8 진수이다.
.B \-\-
인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다.
모드를 성공적으로 변경하거나 아무런 \fI모드\fP 값도 적지 않으면 반환
상태값은 0 이고 그 나머지 경우에 대해서는 거짓이다.
.TP
\fBunalias\fP [\-\fBa\fP] [\fI이름\fP ...]
정의된 앨리어스 목록에서 \fI이름\fP을 제거한다.
.B \-a
를 적으면 모든 앨리어스 정의를 제거한다.
적은
.I 이름
이 정의되어 있는 앨리어스가 아닌 경우를 제외하고 반환값은 참이다.
.TP
\fBunset\fP [\-\fBfv\fP] [\fI이름\fP ...]
각각의
.IR 이름
에 대하여,
해당하는 변수를 제거하거나,
.B \-f
옵션의 경우 함수를 제거한다.
.B \-\-
인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다.
.SM
.BR PATH ,
.SM
.BR IFS ,
.SM
.BR PPID ,
.SM
.BR PS1 ,
.SM
.BR PS2 ,
.SM
.BR UID ,
그리고
.SM
.B EUID
는 unset할 수 없다.
.SM
.BR RANDOM ,
.SM
.BR SECONDS ,
.SM
.BR LINENO ,
또는
.SM
.B HISTCMD
중 하나를 unset하면, 그 값은 나중에 다시 설정한다 할 지라도 고유의 특성을
잃게 된다.
.I 이름
이 존재하지 않거나 unset할 수 없는 것이 아닌 한, 종료 상태값은 참이다.
.TP
\fBwait\fP [\fIn\fP]
특정 프로세스를 기다리다가 종료값을 반환한다.
.I n
은 프로세스 ID이거나 작업 스펙이다;
작업 스펙이면 그 작업의 파이프라인에 존재하는 모든 프로세스를 기다린다.
.I n
을 적지 않으면, 현재 활성 중인 모든 프로세스를 기다리며 반환값은 0 이다.
.I n
이 존재하지 않는 프로세스 또는 작업을 가리키는 경우 반환 상태값은 127 이다.
그렇지 않으면, 반환값은 기다렸던 마지막 프로세스 또는 작업의 종료 상태값이
된다.
.\" bash_builtins
.if \n(zZ=1 .ig zZ
.SH 호출(INVOCATION)
\fI로그인 쉘\fP이란 0 번째 인수의 첫번째 문자가 
.BR \-
이거나
플래그를 주어 시작한 쉘이다.
.PP
\fI대화형(interactive)\fP 쉘이라면 쉘의 표준 입력과 표준 출력 둘 다 터미널에
연결되어 있는 쉘
(그 여부는
.IR isatty (3)
를 통해 판단한다.) 또는
.B \-i
옵션을 주어 시작한 쉘이다.
.SM
.B bash
가 대화형 모드일 때에는
쉘 스크립트나 시동 파일에서 두 가지 상태를 판단할 수 있도록
.B PS1
를 설정하고
.B $\-
에 i 를 포함한다.
.PP
.nf
로그인 쉘:
  로그인할 때 (\fB\-noprofile\fP 옵션에 따라 달라진다):
        만약 \fI/etc/profile\fP이 있으면, 그것을 소스(source)한다.

        만약 \fI~/.bash_profile\fP이 있으면 소스한다.
          그렇지 않고 \fI~/.bash_login\fP이 존재하면 그것을 소스한다.
            그렇지 않고 \fI~/.profile\fP이 존재하면 그것을 소스한다.

  종료할 때:
        만약 \fI~/.bash_logout\fP이 존재하면 소스한다.

로그인이 아닌 대화형 쉘:
  시동할 때 (\fB\-norc\fP와 \fB\-rcfile\fP 옵션에 따라 달라진다):
        만약 \fI~/.bashrc\fP이 존재하면 소스한다.

대화형 쉘이 아닌 쉘:
  시동할 때:
        if the environment variable \fBENV\fP is non-null, expand
	만약 환경 변수 \fBENV\fP가 널이 아니면, 확장한 뒤, 가리키는
	파일을 소스한다.  마치 다음과 같은 루틴이라고 보면 된다.
                if [ "$ENV" ]; then . $ENV; fi
	그러나 경로명에 탐색을 위해서는 \fBPATH\fP를 사용하지 않는다.
	POSIX 모드로 시동하지 않았다면, bash는 \fBENV\fP를 찾기 전에
        \fBBASH_ENV\fP를 찾는다.
.PP
.fi
.PP
bash를
.BR sh
라는 이름으로 호출하면,
가능한 최대한
.B sh
의 행동 방식을 흉내내려 한다.  로그인 쉘의 경우,
.I /etc/profile
와
.IR ~/.profile ,
만을 순서대로 소스한다.
.B \-noprofile
옵션을 주면 이런 행동 방식을 방지할 수 있다.
.B sh
라는 이름으로 호출할 쉘은 기타 다른 시동 파일을 소스하지 않는다.
.PP
.B \-posix
명령행 옵션을 주어
.B bash 
를 
.I posix
모드로 시작하면 시동 파일에 대하여
POSIX 표준에 따른다.
이 모드에서는
.B ENV
변수를 확장하여 그 파일을 소스한다;  다른 시동 파일을 읽지 않는다.
.SH "참고 사항"
.PD 0
.TP
\fIBash Features\fP, Brian Fox and Chet Ramey
.TP
\fIThe Gnu Readline Library\fP, Brian Fox and Chet Ramey
.TP
\fIThe Gnu History Library\fP, Brian Fox and Chet Ramey
.TP
\fIA System V Compatible Implementation of 4.2\s-1BSD\s+1 Job Control\fP, David Lennert
.TP
\fIPortable Operating System Interface (POSIX) Part 2: Shell and Utilities\fP, IEEE
.TP
\fIsh\fP(1), \fIksh\fP(1), \fIcsh\fP(1)
.TP
\fIemacs\fP(1), \fIvi\fP(1)
.TP
\fIreadline\fP(3)
.PD
.SH 파일
.PD 0
.TP
.FN /bin/bash
\fBbash\fP 실행파일
.TP
.FN /etc/profile
시스템 전역 초기화 파일로서 로그인 쉘에서 실행
.TP
.FN ~/.bash_profile
개인 초기화 파일로서 로그인 쉘에서 실행
.TP
.FN ~/.bashrc
각각의 대화형 쉘에 대한 개별 시동 파일
.TP
.FN ~/.inputrc
개별적인 \fIreadline\fP 초기화 파일
.PD
.SH 저자
.RS
Brian Fox, Free Software Foundation (주 개발자)
.br
bfox@ai.MIT.Edu
.PP
Chet Ramey, Case Western Reserve University
.br
chet@ins.CWRU.Edu
.SH 버그 보고
.B bash
에서 버그를 발견하면 보고해야 한다.
우선 진짜로 버그인지 확실히 하고 
최신 버전의
.B bash
인지 확인하라.
.PP
일단 정말로 버그가 있다고 생각했다면
.I bashbug
명령을 사용하여 버그를 보고한다.
고친 내용이 있다면 그 내용을 메일로 보낸다면 환영이다!
제안 사항이나 `철학적인' 버그 보고는 
\fPbug-bash\fP@\fIprep.ai.MIT.Edu\fP에 메일을 쓰거나
유즈넷 뉴스그룹인
.BR gnu.bash.bug
에 글을 적는다.
.PP
모든 버그 보고는 다음을 포함해야 한다:
.PP
.PD 0
.TP 20
\fBbash\fR의 버전 번호
.TP
하드웨어와 운영체계
.TP
컴파일 시 사용한 컴파일러
.TP
버그에 대한 설명
.TP
버그를 내는 간단한 스크립트 또는 'recipe'
.PD
.PP
.I bashbug
는 버그 보고 시에 사용하는 템플릿에
처음 나오는 3 가지 항목을 자동으로 추가해 준다.
.PP
매뉴얼 페이지에 대한 언급과 버그 보그는
.IR chet@ins.CWRU.Edu
로 보낸다.
.SH 버그
.PP
너무 크고 너무 느리다.
.PP
.B bash
와 전통적인
.BR sh 
버전 간에 약간의 미묘한 차이점이 존재한다.
그 중 대부분은
.SM
.B POSIX
스펙에 의한 것이다.
.PP
앨리어스는 일부 사용법에서 혼란스럽다.
.SH 번역자
.PP
.RS
이 만 용, 알짜 리눅스
.br
Man-Yong Lee, ALZZA LINUX
.PP
.br
yong@alzzalinux.com
.br
geoman@nownuri.net
.PP
번역에 대한 버그 보고 또는 제한 사항은 위 메일로 보내기 바란다.
.zZ
