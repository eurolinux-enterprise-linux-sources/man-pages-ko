.PU
.TH bzip2 1
.SH 이름
bzip2, bunzip2 \- 블럭 정렬 파일 압축기, v0.9.5
.br
bzcat \- 파일의 압축을 풀어 stdout으로 보냄
.br
bzip2recover \- 손상된 bzip2 파일로부터 자료를 복구

.SH 사용법
.ll +8
.B bzip2
.RB [ " \-cdfkqstvzVL123456789 " ]
[
.I "filenames \&..."
]
.ll -8
.br
.B bunzip2
.RB [ " \-fkvsVL " ]
[ 
.I "filenames \&..."
]
.br
.B bzcat
.RB [ " \-s " ]
[ 
.I "filenames \&..."
]
.br
.B bzip2recover
.I "filename"

.SH 설명
.I bzip2
는 Burrows-Wheeler 블럭 정렬 텍스트 압축 알고리즘과 Huffman 코딩을 이용하여
파일을 압축한다.
이 압축은 전통적인 LZ77/LZ78 기반의 압축기에 의해 이루어지는 압축보다 일반적으로 상당히 좋다.
그리고 통계적인 압축기중 PPM 계열의 성능에 근접한다.

명령행 옵션은 
.I GNU gzip 
의 그것과 매우 유사하나 동일하지는 않다.

.I bzip2
명령행 플래그 다음에 파일 이름의 목록이 올 것으로 예상한다.
각각의 파일은 그것들의 압축된 상태로 대체되는데, 파일 이름은 "원래이름.bz2"이 된다.  
각각의 압축된 파일은 같은 수정 날짜, 퍼미션, 그리고 가능하다면 원본에 대응하는 소유자를 갖는다.
그래서 이러한 속성이 압축을 풀때 정확하게 복구될 수 있다.
파일명 처리는 파일명, 허가권, 소유자 혹은 날짜 개념이 없는 파일 시스템이나
파일명의 길이에 심각한 제한이 있는 MS-DOS 같은 경우는 원래의 속성을
보존할 수 있는 방법이 없으므로 단순하다고 할 수 있다.

.I bzip2
과
.I bunzip2
는 기본적으로 존재하는 파일을 덮어쓰지 않는다.
이렇게 하려면, \-f 플래그를 사용하라.

만약 파일 이름이 지정되지 않으면,
.I bzip2
는 표준 입력을 압축하여 표준 출력으로 보낸다.
이 경우에,
.I bzip2
는 압축된 출력을 터미널로 보낸다.
그래서 이 출력은 모두 이해할 수 없으며 무의미하다.

.I bunzip2
(혹은
.I bzip2 \-d) 
은 모든 지정된 파일의 압축을 푼다. 
.I bzip2
에 의해 생성되지 않은 파일이 발견되면 무시되고, 경고를 출력할 것이다.
.I bzip2
는 압축이 풀린 파일의 이름을 압축된 파일로부터 다음과 같이 추측할 것이다.

       filename.bz2    becomes   filename
       filename.bz     becomes   filename
       filename.tbz2   becomes   filename.tar
       filename.tbz    becomes   filename.tar
       anyothername    becomes   anyothername.out

만약 파일이 인식될 수 없는 확장자로 끝나면
.I .bz2, 
.I .bz, 
.I .tbz2
또는
.I .tbz, 
.I bzip2 
는 그것이 원본 파일의 이름을 추측할수 없다고 불평하면서, 원래 파일 이름에
.I .out
이 추가된 이름을 사용할 것이다.

압축할때와 마찬가지로, 파일 이름을 넣어주지 않으면 표준 입력으로부터
압축을 풀어서 표준 출력으로 보낼 것이다.

.I bunzip2 
은 두개나 그 이상의 압축된 파일의 연결을 정확히 풀어낼 것이다.
그 결과는 대응하는 압축해제된 파일의 연속이다.
연결된 압축 파일의 무결성 검사(\-t) 역시 지원된다.

또한 당신은 \-c 플래그를 사용하여 압축된 파일을 표준 출력으로 보낼 수 있다.
다중 파일은 이렇게 압축되고 풀릴 수 있다.
결과는 차례로 stdout으로 공급된다.
다중 파일을 이런 방식으로 압축하는 것은 다중 압축 파일 표시를 포함하는
스트림을 생성하게 된다.
이러한 스트림은 오직
.I bzip2 
버전 0.9.0 이나 이후버전에서서만 정확하게 압축해제될 수 있다.
.I bzip2
의 이전 버전은 스트림의 첫번째 파일을 압축해제 후 멈출 것이다.
.I bzcat
(혹은
.I bzip2 -dc) 
은 지정된 모든 파일의 압축을 풀어서 표준 출력으로 보낸다.

.I bzip2
은 환경변수인
.I BZIP2
과
.I BZIP
으로부터 인자를 읽어들이고, 명령행에서 인자를 읽기 전에 먼저
이 순서대로 처리할 것이다.
이것은 기본 인자를 사용하기에 편리한 방법을 제공한다.

압축된 파일의 크키가 원본보다 약간 크더라도 압축은 항상 수행된다.
대략 100바이트 이하의 파일들은 약간 커지는 경향이 있다.
왜냐하면 압축 기법은 50바이트의 영역에 상수 오버헤드를 가지기 때문이다.
난수 자료(대부분의 파일 압축기의 출력을 포함한)는 0.5% 가량이 확장된
바이트 당 8.05bit 정도로 부호화된다.

당신의 보호를 위한 자체 검사로서, 
.I bzip2
은 압축해제된 파일이 원본과 동일한지 비교하기 위해 32 비트 CRC를 사용한다.
이것은 압축된 자료의 손상과 발견되지 않은
.I bzip2
의 버그(거의 그럴리가 없지만)로부터 보호하도록 한다.
발견되지 않은 자료상의 가능성은 매우 낮아서, 처리되는 파일당 40억(4 billion) 분의 1정도이다.
그러나 검사가 압축해제시에만 행해지므로 당신은 무엇인가가 잘못되었다는 것만 알 수 있다는 것을 인지하라.
그것이 원래의 압축해제된 자료를 복구하도록 돕지는 않는다.
손상된 파일에서 자료를 복구하기위해서 
.I bzip2recover
를 사용할 수 있다.

반환값 : 0 정상 종료, 1 환경적인 문제 (파일이 발견되지 않음,
유효하지 않은 플래그, I/O 에러,&c), 2 손상된 압축 파일을 암시
, 3
.I bzip2
를 공황 상태로 만드는 내부 문제 (예, 버그)

.SH 옵션
.TP
.B \-c --stdout
압축이나 해제를 해서 표준 출력으로 보낸다.
.TP
.B \-d --decompress
강제 압축해제  
.I bzip2, 
.I bunzip2 
그리고
.I bzcat 
는 실제로 같은 프로그램이다.
그리고 어떤 행동이 취해질지는 사용된 이름에 의해 결정된다.
이 플래그는 그 방법을 무시하고 강제로
.I bzip2
이 압축해제를 하도록 한다.
.TP
.B \-z --compress
\-d 의 반대 : 불려진 이름에 상관없이 압축
.TP
.B \-t --test
지정된 파일의 무결성을 검사하지만, 압축을 풀지는 않는다.
이것은 사실 실험적으로 압축해제를 하고 결과값을 버린다.
.TP
.B \-f --force
출력 파일을 강제로 덮어쓴다.
보통,
.I bzip2 
은 존재하는 출력 파일을 덮어쓰지 않는다.
또한 원래는 그렇지 않으나 이 경우
.I bzip2 
이 파일에 대한 하드 링크를 없애도록 한다.
.TP
.B \-k --keep
압축이나 해제하는 동안 입력 파일을 유지한다(지우지 않는다.)
.TP
.B \-s --small
압축, 해제와 테스트에 사용하는 메모리의 양을 줄인다.
파일들은 단위 바이트당 오직 2.5바이트만을 필요로하는 수정된 알고리즘을 이용해 압축해제되고 검사된다.
이것은 비록 정상 속도의 절반이기는 하지만 어떤 파일이든지 2300k 의 메모리에서 압축해제될 수 있다는 것을 의미한다.

압축과정중에, \-s 는 200k 의 블럭 크기를 선택하도록 하는데, 메모리 사용을 같은 수치로 제한한다. 대신에 압축 비율을 희생해야 한다. 
즉, 당신의 기계의 메모리가 적다면(8 메가바이트나 이하),
모든것에 \-s 를 사용하라. 아래의 메모리 관리를 참조하라.
.TP
.B \-q --quiet
불필요한 경고 메시지를 무시한다.
I/O 에러와 다른 치명적인 사건을 포함한 메시지는 무시되지 않을 것이다.
.TP
.B \-v --verbose
장황한 모드 -- 처리된 각 파일의 압축 비율을 출력한다.
\-v 를 덧붙이면 장황한 정도를 증가시켜서,
진단을 목적으로 하는 흥미가 주된 정보를 잔뜩 출력하게 된다.
.TP
.B \-L --license -V --version
소프트웨어 버전, 라이센스 조항과 조건을 출력한다.
.TP
.B \-1 to \-9
압축할때 블럭 크기를 100 k, 200 k ..  900 k 로 설정한다.
압축해제시에는 아무런 영향이 없다.
아래의 메모리 관리를 참조하라.
.TP
.B \--
다음에 오는 모든 인자들을 파일이름으로 취급한다. 비록 \- 로 시작하더라도.
이것은 \- 로 시작하는 파일을 다룰 수 있도록 해준다. 
예를 들자면 bzip2 \-- \-myfilename.
.TP
.B \--repetitive-fast --repetitive-best
이 플래그들은 버전 0.9.5 와 이상에서는 여분이다.
그들은 이전 버전에서 정렬 알고리즘의 행동에 대해 어떤 조잡한 제어를 제공했다.
이러한 제어가 때로는 유용하기도 했다.
0.9.5 와 그 이상의 버전은 이러한 플래그를 무의미하게 하는 향상된 알고리즘을 지닌다.

.SH 메모리 관리
.I bzip2 
는 큰 파일을 블럭으로 압축한다.
블럭 크기는 압축된 비율, 그리고 압축과 해제에 필요한 메모리의 양 모두에 영향을 준다.
\-1 에서 \-9 까지의 플래그는 각각 블럭 크기를 100,000 바이트에서 900,000 바이트(기본값)가
되도록 지정한다. 
압축해제시에, 압축에 사용된 블럭의 크기가 압축된 파일의 헤더에서 읽혀지고,
.I bunzip2
는 그 파일을 풀기에 충분한 메모리를 자신에게 할당한다. 
블럭 크기가 압축된 파일에 저장되므로, 여기서 \-1 에서 \-9 플래그들은 무의미하고
압축해제동안 무시된다. 

압축과 해제시에 요구량은 바이트로 다음과 같이 예측할 수 있다.

       압축	: 400k + ( 8 x 블럭 크기 )

       해제	: 100k + ( 4 x 블럭 크기), 또는
                      100k + ( 2.5 x 블럭 크기 )

보다 큰 블럭들은 경계의 반환을 급속히 감소시킬 것이다. 
압축의 대부분은 블럭 크기의 첫 2,3백 킬로 바이트에서 결정되고,
이것은
.I bzip2
를 소형의 기계에서 사용할때 기억해둘만한 사실이다.
압축해제시의 메모리 요구량은 압축시에 블럭 크기의 선택에 따라 결정된다는 것을 이해하는 것이 중요하다. 
기본값 900k 블럭 크기로 압축된 파일에 대해서,
.I bunzip2
압축해제를 위해 3700k 바이트의 메모리를 요구할 것이다.
4 메가바이트의 기계에서 어떤 파일이든지 압축을 풀기 위해서
.I bunzip2
는 이 메모리양의 대략 절반인 2300k 바이트를 사용해서 압축해제를 하는 옵션을 갖고 있다.
압축해제 속도 역시 절반이 되므로, 꼭 필요한 때만 이 옵션을 사용하라.
관련된 플래그는 \-s이다.

일반적으로, 메모리 제한이 허락하는 가장 큰 블럭 크기를 시도해보고 사용하라.
왜냐하면 이것이 압축을 최대화하기 때문이다.
압축과 해제 속도는 블럭 크기에 의해서는 실질적으로 영향을 받지 않는다.

또다른 중요한 특징이 단일 블럭에 맞는 파일에 적용된다. 
-- 마주치게 되는 대부분의 파일들을 큰 블럭 크기를 이용하는 것을 의미한다.
파일은 블럭보다 작기 때문에, 사용하게 되는 실제 메모리의 양은 파일의 크기에 비례한다.
예를 들어, 20,000 바이트의 파일을 -9 플래그로 압축하는 것은 압축기가 7600k 의 메모리를 할당하도록 하지만, 단지 그것중 400k + 20000 * 8 = 560 킬로바이트만을 사용한다.
유사하게, 압축해제기도 3700k의 메모리를 할당하고 100k + 20000 * 4 = 180 킬로바이트만을 사용할 것이다.

이것은 다른 블럭 크기에 대한 최대 메모리 사용을 요약한 표이다.
함께 기록된 것은 Calgary Text Compression Corpus 의 14개 파일들(전부 3,141,622 바이트)의
전체가 압축된 크기이다.
이 칼럼은 블럭의 크기에 따라 압축이 어떻게 변하는지에 대해 어떤 감을 준다.
이러한 특징들은 큰 파일에 큰 블럭 크기를 사용하는 것의 장점을 짧게 말하고 있다.
왜냐하면 Corpus는 작은 파일이 우세하기 때문이다.

           Compress   Decompress   Decompress   Corpus
    Flag     usage      usage       -s usage     Size

     -1      1200k       500k         350k      914704
     -2      2000k       900k         600k      877703
     -3      2800k      1300k         850k      860338
     -4      3600k      1700k        1100k      846899
     -5      4400k      2100k        1350k      845160
     -6      5200k      2500k        1600k      838626
     -7      6100k      2900k        1850k      834096
     -8      6800k      3300k        2100k      828642
     -9      7600k      3700k        2350k      828642

.SH 손상된 파일로부터 자료 복구
.I bzip2
는 파일을 블럭으로 압축하는데, 대개 900k 바이트의 길이다.
각각의 블럭은 독립적으로 다루어진다.
만약 매체나 전송 에러가 다중 블럭화된 .bz2파일을 손상시킨다면,
파일의 손상되지 않은 블럭으로부터 자료를 복구할 수도 있다.

각각의 블럭의 압축된 내용은 48비트의 패턴에 의해 구분된다.
이 패턴은 적절한 정확성으로 블럭의 경계를 찾을 수 있도록 한다.
각각의 블럭은 자체의 32비트 CRC를 가지고 있는데,
그래서 손상된 블럭은 손상되지 않은 것들로부터 구분될수 있다.

.I bzip2recover
는 .bz2 파일에서 블럭을 탐색해서 각각의 블럭을 자체의 .bz2 파일에 기록해두는
간단한 프로그램이다.
당신은 
.I bzip2 
\-t
를 이용하여 생성된 결과 파일의 무결성을 검사하고, 손상되지 않은 것들의
압축을 해제할 수 있다.

.I bzip2recover
는 한가지 인자를 받아들이는데, 손상된 파일의 이름이다.
그리고 추출된 블럭들을 포함하는 "rec0001file.bz2", "rec0002file.bz2" 등과 같은
여러개의 파일에 기록해둔다.
출력 파일들의 이름은 순차 처리에서 와일드카드를 사용할 수 있도록 만들어졌다.
예를 들자면 "bzip2 -dc  rec*file.bz2 > recovered_data" 은 정확한 순서로
파일의 목록을 만든다.

.I bzip2recover
는 큰 .bz2 파일을 다루는 데 가장 유용할 것이다.
왜냐하면 이것들은 많은 블럭들을 포함하고 있기 때문이다.
그것을 손상된 단일블럭의 파일에 사용하는 것은 전혀 쓸데없는 일이다.
손상된 블럭은 복구될 수 없기 때문이다.
만약 매체나 전송의 에러로 인산 어떤 잠재적인 자료 손실도 최소화하고 싶다면
보다 작은 블럭 크기로 압축하는 것을 고려해야 할 것이다.

.SH 성능의 특징
압축의 정렬 단계에서는 파일내에서 비슷한 문자열을 함께 모은다.
이 때문에, "aabaabaabaab ..." 같은 반복되는 기호가 오랫동안 계속되는 파일은(수배번정도)
보통보다 느리게 압축될 것이다. 
버전 0.9.5 와 그 이상은	이런 경우에 이전 버전보다 좋은 성능을 보인다.
최악의 경우와 평균적인 경우의 압축 시간의 비율은 10:1 정도인데.
이전 버전에서는, 100:1에 가까웠다.
당신은 원한다면
\-vvvv 옵션을 이용하여 아주 자세하게 상황을 감시할수도 있다.

압축 해제 속도는 이러한 현상에 의해 영향을 받지 않는다.

.I bzip2
는 대개 작업을 위해 수 메가바이트의 메모리를 할당한다.
그리고 완전히 무작위한 방법으로 그것을 채운다.
이것은 압축과 해제 성능 모두가 당신의 기계가 서비스할수 있는 캐쉬 실패 속도에
따라 크게 결정됨을 의미한다.
이 때문에, 실패율을 감소시키기 위한 코드에의 작은 변화가 어울리지 않는 커다란 성능 향상을 가져오는 것으로 관찰되었다.
나는 
.I bzip2
가 매우 큰 캐쉬를 가진 기계에서 최상의 성능을 낼 것이라 생각한다.

.SH 경고
I/O 에러 메시지는 원래 그들이 가능한 만큼 도움이 되지는 못한다.
.I bzip2
는 I/O 에러를 발견하고 깨끗하게 종료하려고 열심히 노력하지만,
발생한 문제의 상세한 내용은 때로는 오히려 오해하도록 하기도 한다.

이 매뉴얼 페이지는 0.9.5 버전의
.I bzip2  
에 적합하다.
이 버전에 의해 생성된 압축된 자료는 예전의 공개 릴리즈인 버전 0.1pl2와
0.9.0과 이전, 이후의 버전과 완전히 호환된다.
그러나 다음은 제외이다. : 0.9.0 과 그 이상은 다중 연결된 압축 파일을
정확하게 풀어낼 수 있다. 0.1pl2는 그렇지 못하고 스트림에서 첫번째
파일을 풀어낸 후 멈출 것이다. 

.I bzip2recover
는 압축된 파일의 비트 상태를 표현하기 위해 32 비트 정수를 사용한다.
그래서 512 메가 이상의 압축된 파일은 다룰 수 없다.
이것은 쉽게 수정될 수 있다.

.SH 저자
Julian Seward, jseward@acm.org.

http://www.muraroa.demon.co.uk

.I bzip2
에서 구체화되어 있는 생각들은 (적어도) 다음 사람들의 덕이다 :
Michael Burrows 과 David Wheeler (블럭 소팅 변형에 대해서),
David Wheeler (또, Huffman 코더에 대해서),
Peter Fenwick (최초의
.I bzip,
에서의 구조화된 코딩 모델과 많은 개선점들에 대해),
그리고 Alistair Moffat, Radford Neal 과 Ian Witten (최초의
.I bzip  
에서의 계산 코더에 대해).

나는 그들의 도움, 지원과 충고에 많은 빚을 졌다.
문서화의 소스에 대한 지침을 보려면 소스 배포판의 매뉴얼을 보라.
Christian von Roques 는 압축의 속도를 증가시키기 위해 보다 빠른 정렬 알고리즘을 찾도록 격려해주었다. 
Bela Lubkin 은 내가 최악의 경우의 압축 성능을 개선하도록 격려했다.
많은 사람들이 패치를 보내줬고, 이식 문제에 대해 도왔으며, 기계를 빌려주었고, 충고를 해줬으며 이것들은 매우 도움이 되었다.

.SH 역자
서성용 <pooh@kldp.org>,	2000년 5월 31일

