.TH KILLALL 1 "1999년 9월 7일" "리눅스" "사용자 명령"
.SH 이름
killall \- 이름에 의해 프로세스를 죽인다.
.SH 사용법
.ad l
.B killall
.RB [ \-egiqvw ]
.RB [ \-\fIsignal\fB ]
.I name ...
.br
.B killall
.RB \-l
.br
.B killall
.RB \-V
.ad b
.SH 설명
.B killall
은 지정된 명령이 실행중인 모든 프로세스에 시그널을 보낸다.
만약 시그널 이름이 지정되지 않으면, SIGTERM 이 보내진다.
.PP
시그널은 이름이나(예를 들면, \fB\-HUP\fP) 숫자에 의해(에를 들면, \fB\-1\fP) 지정될 수 있다. 시그널 0 (프로세스가 존재하는지 검사) 는 오직 숫자에 의해서만 지정될 수 있다.
.PP
만약 명령 이름이 슬래쉬(\fB/\fP)를 포함한다면, 특정한 파일을 실행중인 프로세스들은 이름에 상관없이 죽도록 선택된다.
.PP
\fBkillall\fP 는 나열된 명령에서 아무런 프로세스도 죽지 않으면 0이 아닌 코드를 반환한다.
만약 각 명령마다 최소한 하나의 프로세스라도 죽었으면, \fBkillall\fP는 0을 반환한다.
.PP
\fBkillall\fP 프로세스는 절대 자기자신을 죽이지 않는다(그러나 다른 \fBkillall\fP 는 죽일 수 있다).
.SH 옵션
.IP \fB\-e\fP
매우 긴 이름에 대해 정확한 짝을 요구한다.
만약 명령 이름이 15글자가 넘으면, 완전한 이름은 이용불가능할수도 있다
(다시 말하면 그것이 바뀔수 있다는 것이다.)
이런 경우에, \fBkillall\fP 는 처음 15자 이내가 맞는 것은 모두 죽일 것이다.
\fB\-e\fP 옵션을 지정하면, 이러한 영역은 지나치게 된다.
\fBkillall\fP 는 \fB\-v\fP 옵션이 \fB\-e\fP 옵션과 함께 지정되어 있으면,
각각의 지나친 엔트리마다 메시지를 출력한다.
.IP \fB\-g\fP
프로세스가 속한 프로세스 그룹을 죽인다.
같은 프로세스 그룹에 속한 여러개의 프로세스들이 발견되더라도 시그널은 그룹당 한번만 보내진다.
.IP \fB\-i\fP
죽이기전에 확인을 위해 상호적으로 물어본다.
.IP \fB\-l\fP
알려진 모든 시그널 이름 목록을 보여준다.
.IP \fB\-q\fP
프로세스가 전혀 죽지 않았어도 불평하지 않는다.
.IP \fB\-v\fP
시그널이 성공적으로 보내졌다면 보고한다.
.IP \fB\-V\fP
버전 정보를 출력한다.
.IP \fB\-w\fP
모든 죽여진 프로세스들이 죽도록 기다린다. \fBkiiall\fP 는 1 초에 한번씩 죽여진 프로세스들이 여전시 존재하는지 검사해서 아무것도 남지 않게 될때 반환한다.
\fBkillall\fP 는 시그널이 무시되거나, 영향이 없을 경우, 프로세스가 좀비 상태에 머무르게 될 경우에 영원히 기다릴 수도 있음에 유의하라.
.SH 파일
.nf
/proc	proc 파일 시스템의 위치
.fi
.SH "알려진 버그들"
파일에 의해서 죽이는 것은 실행중에 개방된 실행파일에 대해서만 동작한다.
즉, 순수 실행파일이 아닌것은 이런식으로 죽일 수 없다.
.PP
\fBkillall\fP \fIname\fP 을 치는 것은 리눅스가 아닌 시스템에서는 원하는 결과를 얻지 못할지도 모른다는 것에 유의하라. 특히 특권을 가진 사용자일 경우에 더욱 유의하라.
.PP
\fBkillall \-w\fP 는 검색하는 동안 어떤 프로세스가 없어지고 같은 PID를 가진 다른 프로세스로 치환되더라도 탐지하지 못한다.
.SH 저자
Werner Almesberger <Werner.Almesberger@epfl.ch>
.SH 관련 항목
kill(1), fuser(1), pidof(1), ps(1), kill(2)
.SH 역자
서성용 <pooh@kldp.org> 2000년 6월 2일



.\"{{{}}}

