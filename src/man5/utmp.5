.\" Copyright (c) 1993 Michael Haardt (michael@cantor.informatik.rwth-aachen.de), Fri Apr  2 11:32:09 MET DST 1993
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\" 
.\" Modified Sun Jul 25 10:44:50 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified Thu Feb 26 16:08:49 MET 1995 by Michael Haardt
.\" Modified Sat Jul 20 14:39:03 MET DST 1996 by Michael Haardt
.\" Modified Wed Jul  2 20:20:53 ART 1997 by Nicol? Lichtmaier <nick@debian.org>
.\"
.\" 한국어 번역 : ASPLINUX<man@asp-linux.co.kr>    2000년 7월 29일
.\"
.TH UTMP 5 "1997년 7월 2일" "" "파일 포맷"
.SH 이름
utmp, wtmp \- 로그인 레코드.
.SH 사용법
#include <utmp.h>
.SH 설명
.B utmp
파일은 현재 누가 시스템을 사용하고 있는지에 대한 정보를 알려준다. 
모든 프로그램이 utmp 로그를 사용하는 것은 아니기 때문에, 현재 더 많은 사용자가 있을 수 있다.
.PP
\fBWarning:\fP \fButmp\fP 는 쓰기가 가능하지 않아야 한다. 왜냐하면 많은 프로그램 들이 (어리석게도) 이것의 완전하리라 생각하기 때문이다. \fButmp\fP 를 쓰기가능 상태로 두면, 가짜 시스템 로그파일이 생길 수도 있고, 시스템 파일이 변경 될 수도 있다.
.PP
이 파일은 안에 포함된 파일에 선언된 구조에 따른 엔트리의 시퀀스이다.
(이것은 여러 정의 중 하나임을 명심하자; 자세한 것은 libc의 버전에 따라 다르다.):
.RS
.nf
.sp
.ta 3i
#define UT_UNKNOWN	0
#define RUN_LVL		1
#define BOOT_TIME	2
#define NEW_TIME	3
#define OLD_TIME	4
#define INIT_PROCESS	5
#define LOGIN_PROCESS	6
#define USER_PROCESS	7
#define DEAD_PROCESS	8
#define ACCOUNTING	9

#define UT_LINESIZE	12
#define UT_NAMESIZE	32
#define UT_HOSTSIZE	256

struct exit_status {
  short int e_termination;	/* process termination status.  */
  short int e_exit;	/* process exit status.  */
};

struct utmp {
  short ut_type;	/* type of login */
  pid_t ut_pid;	/* pid of login process */
  char ut_line[UT_LINESIZE];	/* device name of tty \- "/dev/" */
  char ut_id[4];	/* init id or abbrev. ttyname */
  char ut_user[UT_NAMESIZE];	/* user name */
  char ut_host[UT_HOSTSIZE];	/* hostname for remote login */
  struct exit_status ut_exit;	/* The exit status of a process
	   marked as DEAD_PROCESS. */
  long ut_session;	/* session ID, used for windowing*/
  struct timeval ut_tv;	/* time entry was made.  */
  int32_t ut_addr_v6[4];	/* IP address of remote host.  */
  char pad[20];	/* Reserved for future use.  */
};

/* Backwards compatibility hacks.  */
#define ut_name ut_user
#ifndef _NO_UT_TIME
#define ut_time ut_tv.tv_sec
#endif
#define ut_xtime ut_tv.tv_sec
#define ut_addr ut_addr_v6[0]
.sp
.fi
.RE
이 구조는 사용자의 터미널, 사용자의 로그인명, 
.BR time (2)
의 형태로 나타낸 로그인 시간에 관련된 특수 파일의 이름을 출력한다.
영역의 크기보다 작다면 문자열 영역은 \fB'\e0'\fP로 끝난다.
.PP
첫번째 엔트리는 항상 \fIinittab\fP(5)를 실행하는 \fIinit\fP(8)로 인한 결과를 생성한다.
엔트리가 실행되기 전에, \fIinit\fP(8)는 \fBut_type\fP를 \fBDEAD_PROCESS\fP로 설정하고, \fBut_type\fP는 \fBDEAD_PROCESS\fP나 \fBRUN_LVL\fP가 아니고, PID \fBut_pid\fP로 실행하는 것이 없는 각각의 기록을 위해,\fBut_user\fP, \fBut_host\fP, \fBut_time\fP을 null 바이트로 지움으로써 utmp를 지운다. 
필요한 \fBut_id\fP 에 빈 기록을 찾을 수 없다면, init는 새로운 것을 만든다.
이것은 inittab, \fBut_pid\fP, \fBut_time\fP로부터 \fBut_id\fP을 현제 값으로, \fBut_type\fP을 \fBINIT_PROCESS\fP로 설정한다.
.PP
\fIgetty\fP(8)는 pid로 엔트리를 찾고, \fBut_type\fP를 \fBLOGIN_PROCESS\fP로 바꾸고, \fBut_time\fP을 바꾸고, \fBut_line\fP을 설정하고, 접속을 기다린다.
믿을 수 있음이 증명된 후에, \fIlogin\fP(8)은 \fBut_type\fP을 \fBUSER_PROCESS\fP로 바꾸고, \fBut_time\fP을 바꾸고, \fBut_host\fP와 \fBut_addr\fP을 설정한다
\fIgetty\fP(8)와 \fIlogin\fP(8)에 따라, 기록은 적당한 \fBut_pid\fP 대신, \fBut_line\fP으로 발견된다.

.PP

\fIinit\fP(8)는 프로세스가 종료된 것을 발견하면, utmp 항목을  \fBut_pid\fP 옆에 
위치시키고, \fBut_type\fP를 READ_PROCESS\fP으로 설정하며, \fBut_user\fP, 
\fBut_host\fP 그리고 \fBut_time\fP를  null 바이트로 소거한다.  

\fIxterm\fP(1)와 다른 터미널 에뮬레이터는 \fBUSER_PROCESS\fP 기록을 만들고, 
\fB/dev/ttyp\fP\fI%c\fP의 마지막 두문자를 사용하거나,   \fB/dev/pts/\fP\fI%d\fP에 
대한 \fBp\fP\fI%d\fP를 사용함으로서, \fBut_id\fP를 생성시킨다. 만일 이들이 이 ID에 대한
 \fBDEAD_PROCESS\fP를 발견한다면, 그들은 이를 재사용할 것이고, 그렇지 않으면, 새로운 엔트리를
만든다. 만일 발견할 수 있다면, 그 아이디를 \fBDEAD_PROCESS\fP로서 표기하고, 이들은 또한   
\fBut_line\fP, \fBut_time\fP, \fBut_user\fP 그리고 \fBut_host\fP로 null 처리한다.

.PP
할당된 터미널이 없으면, \fIxdm\fP(8)는 utmp 기록을 만들어서는 안된다. 이를 하나 만들도록 허용하는 것은 
다음과 같은 문제들의 원인이 된다. 핑거(finger), /dev/machine.dom을 시작할 수 없다. 그러나, 
\fIftpd\fP(8)가 하는 것처럼  wtmp 엔트리를 만들어야 한다. 
.PP
\fItelnetd\fP(8)은 \fBLOGIN_PROCESS\fP 엔트리를 설정하고, \fIlogin\fP(8) 나머지 부분은 
보통과 같이 남겨둔다. 텔넷 세션이 끝난후, \fItelnetd\fP(8)는 utmp는 설명한 방식으로 소거한다. 
.P
\fBwtmp\fP 파일은 모든 로그인과 로그아웃을 기록한다. 이 파일의 포맷은 널 사용자 이름이
관련된 터미널에서 로그아웃을 가리키는 것을 제외하고는 거의 \fButmp\fP과 비슷하다. 더욱이,
사용자 이름 \fB"shutdown"\fP 혹은 \fB"reboot"\fP을 지닌 터미널 이름 \fB"~"\fP은 시스템
 셧다운 혹은 리부트를 가리키고,  터미널 이름쌍 \fB"|"\fP/\fB"}"\fP은  \fIdate\fP(1)이 이를 
변경시킬 때, 오래된/새로운 시스템을 로그로 기록한다.   \fBwtmp\fP은 \fIlogin\fP(1), 
\fIinit\fP(1), WfIgetty\fP(1)의 일부 버전에 의해 유지된다.  이러한 프로그램들중 하나도 파일을 
만들지 못하므로, 만일 삭제되면, 기록 유지는 되지 않는다. 
.SH 파일
/var/run/utmp
.br
/var/log/wtmp
.SH 호환
.  
리눅스 utmp 엔트리는 v7/BSD 이나 SYSV도 따르지 않는다. 이들은 앞의 두가지의 혼합이다. 
v7/BSD는 더적은 필드를 갖고 있으며, 가장 중요한 것은 죽은 엔트리나 로그인 엔트리를 보여주도록 
하는  v7/BSD 유사 프로그램들이 부족하다는데 있다. 더우기, 세션에 슬롯을 할당할 설정파일이 없다. 
\fBut_id\fP 필드가 없기 때문에, BSD는 역시 그러하다. 

리눅스에서, \fBut_id\fP 필드 기록은 일단 설정되면 절대 변경되지 않는다. 즉, 일단 설정 되면, 
설정 파일이 필요없이, 그 슬롯을 남겨둔다.  \fBut_id\fP 를 소거하면, 붕괴된 utmp 
엔트리들과 잠재적인 보안 구멍들을 초래할 수 있는 상태를 만든다. 위에 언급했던 필드들을 null 바이트로
채움으로서 소거하는 것은 SYSV에서는 요구되지 않지만, 많은 프로그램들이 실행되도록 허용한다. 리눅스는
행의 내용에 있어, BSD 전통을 사용한다.  

.PP
SYSV는 이들을 표시하기 위해 오직 유형 필드를 사용하고, 행 필드내에 
\& \fB"new time"\fP와 같은 정보성 메시지들을 기록한다. \fBUT_UNKNOWN\fP는 
리눅스에서만 볼 수 있는 것 같다.  
.PP
이 파일을삭제함으로서 utmp 로깅이 보이는 다양한 다른 시스템들과는 달리, utmp는 리눅스 상에서 
항상 존재한다. 만일 여러분이 \fIwho\fP(1)의 기능을 정지시키면, utmp 영역이 읽혀지지 않도록 해야 한다.  
.PP
libc5에서 utmp 구조체는 libc6내에서 변경되었다는 것을 참조하라. 이 때문에, 이전의 
libc5 구조체를 사용하는 바이너리들은 .IR /var/run/utmp 과 /var/log/wtmp를 붕괴시킨다.

데비안 시스템들은 새로운 utmp 포맷을 사용하는 패치된 libc5를 포함한다.  libc5에서 직접 액세스되기 때문에,
utmp에 있어 문제는 여전히 존재한다.  
.SH RESTRICTIONS
파일 포맷은 머신에 의존적이기 때문에, 이것이 생성되는 머신의 아키텍쳐에서만 처리되도록 하는 것이 좋다. 


.SH 버그
이 맨 페이지는 libc5에 기반하며, 현재와 다르게 동작할 수도 있다. 
.SH 관련 항목
.BR ac (1),
.BR date (1),
.BR getutent (3),
.BR init (8),
.BR last (1),
.BR login (1),
.BR updwtmp (3),
.BR who (1)
